#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport
all_structs = []


class Iface(object):
    """
    KVProxy interface equivalent to kvclient TableAPI.

    """
    def ping(self):
        """
        For checking that the KVProxy server is reachable. *
        """
        pass

    def version(self, whichModule):
        """
        Returns the version string of each module. *

        Parameters:
         - whichModule
        """
        pass

    def status(self, whichModule):
        """
        For checking the status of all the modules. *

        Parameters:
         - whichModule
        """
        pass

    def shutdown(self):
        """
        Shuts down the proxy server if it's allowed *
        """
        pass

    def verify(self, properties):
        """
        Verifies the connection properties: kvstore, credentials, etc.
        The kvStoreHelperHosts list must have at least one entry and all entries
        must be contained in the list that the server was started with.

        Parameters:
         - properties
        """
        pass

    def put(self, tableName, row, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - writeOptions
        """
        pass

    def putIfAbsent(self, tableName, row, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - writeOptions
        """
        pass

    def putIfPresent(self, tableName, row, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - writeOptions
        """
        pass

    def putIfVersion(self, tableName, row, matchVersion, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - matchVersion
         - writeOptions
        """
        pass

    def get(self, tableName, key, readOptions):
        """
        Parameters:
         - tableName
         - key
         - readOptions
        """
        pass

    def deleteRow(self, tableName, key, writeOptions):
        """
        Parameters:
         - tableName
         - key
         - writeOptions
        """
        pass

    def deleteRowIfVersion(self, tableName, key, matchVersion, writeOptions):
        """
        Parameters:
         - tableName
         - key
         - matchVersion
         - writeOptions
        """
        pass

    def multiDelete(self, tableName, key, fieldRange, includedTable, writeOptions):
        """
        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTable
         - writeOptions
        """
        pass

    def multiGet(self, tableName, key, fieldRange, includedTables, readOptions):
        """
        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
        """
        pass

    def multiGetKeys(self, tableName, key, fieldRange, includedTables, readOptions):
        """
        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
        """
        pass

    def tableIterator(self, tableName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value is used.


        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        pass

    def tableIteratorMulti(self, tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint):
        """
        Returns an iterator over the rows matching the primary keys supplied
        (or the rows in ancestor or descendant tables, or those in a
        range specified by the MultiRowOptions argument).

        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value is used.

        @param numParallelIterHint this is a hint that might be used for
        optimizing performance.

        @since version 3


        Parameters:
         - tableName
         - keys
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
         - numParallelIterHint
        """
        pass

    def iteratorNext(self, iteratorId):
        """
        The number of rows in result is linked to the maxResult when the
        iterator was created.


        Parameters:
         - iteratorId
        """
        pass

    def iteratorClose(self, iteratorId):
        """
        There is no need to close an iterator if the last TIteratorResult
        returned contained hasMore == false.


        Parameters:
         - iteratorId
        """
        pass

    def tableKeyIterator(self, tableName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value.


        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        pass

    def tableKeyIteratorMulti(self, tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint):
        """
        Returns an iterator over the keys matching the primary keys supplied by
        iterator (or the rows in ancestor or descendant tables, or those in a
        range specified by the MultiRowOptions argument).

        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value.

        @param numParallelIterHint this is a hint that might be used for
        optimizing performance.

        @since version 3


        Parameters:
         - tableName
         - keys
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
         - numParallelIterHint
        """
        pass

    def indexIterator(self, tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value.


        Parameters:
         - tableName
         - indexName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        pass

    def indexKeyIterator(self, tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        indexKeyIterator returns column values that are part of both the
        primary key and the index key.
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value is used.


        Parameters:
         - tableName
         - indexName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        pass

    def refreshTables(self):
        """
        Refreshes cached information about the tables. This method is
        required before using any tables that had been modified.

        """
        pass

    def executeSync(self, statement):
        """
        Synchronously execute a table statement. The method will only return
        when the statement has finished. Has the same semantics as
        execute(String), but offers synchronous behaviour as a convenience.

        @Deprecated This method is replaced by #executeSyncV2 in
        protocol version 2.


        Parameters:
         - statement
        """
        pass

    def execute(self, statement):
        """
        Asynchronously executes a table statement. Currently, table statements
        can be used to create or modify tables and indices. The operation is
        asynchronous and may not be finished when the method returns.

        A ExecutionFuture identifier (planId) is returned and can be used to get
        information about the status of the operation, or to await completion
        of the operation.

        If the statement is for an administrative command, and the store is
        currently executing an administrative command that is the logical
        equivalent the action specified by the statement, the method will
        return a ExecutionFuture identifier that serves as a handle to that
        operation, rather than starting a new invocation of the command.
        The caller can use the ExecutionFuture identifier to wait for the
        completion of the administrative operation.

        @Deprecated This method is replaced by #executeV2 in
        protocol version 2.


        Parameters:
         - statement
        """
        pass

    def executionFutureCancel(self, planId, mayInterruptIfRunning):
        """
        Attempts to cancel execution of this statement. Return false if the
        statement couldn't be cancelled, possibly because it has already
        finished. If the statement hasn't succeeded already, and can be stopped,
        the operation will transition to the FAILED state.

        @Deprecated This method is replaced by #executionFutureCancelV2 in
        protocol version 2.


        Parameters:
         - planId
         - mayInterruptIfRunning
        """
        pass

    def executionFutureGet(self, planId):
        """
        Blocks until the command represented by this future completes. Returns
        information about the execution of the statement. This call will result
        in communication with the kvstore server.

        @Deprecated This method is replaced by #executionFutureGetV2 in
        protocol version 2.


        Parameters:
         - planId
        """
        pass

    def executionFutureGetTimeout(self, planId, timeoutMs):
        """
        Blocks until the administrative operation has finished or the timeout
        period is exceeded. This call will result in communication with the
        kvstore server.

        @Deprecated This method is replaced by #executionFutureTimeoutV2 in
        protocol version 2.


        Parameters:
         - planId
         - timeoutMs
        """
        pass

    def executionFutureUpdateStatus(self, planId):
        """
        Returns information about the execution of the statement. If the
        statement is still executing, this call will result in communication
        with the kvstore server to obtain up to date status, and the status
        returned will reflect interim information.

        @Deprecated This method is replaced by #executionFutureUpdateStatusV2
         in protocol version 2.


        Parameters:
         - planId
        """
        pass

    def executeSyncV2(self, statement):
        """
        Synchronously execute a table statement. The method will only return
        when the statement has finished. Has the same semantics as
        executeV2(String), but offers synchronous behaviour as a convenience.


        Parameters:
         - statement
        """
        pass

    def executeV2(self, statement):
        """
        Asynchronously executes a table statement. Currently, table statements
        can be used to create or modify tables and indices. The operation is
        asynchronous and may not be finished when the method returns.

        A ExecutionFuture identifier is returned and can be later used to get
        information about the status of the operation, cancel or to await
        completion of the operation.

        If the statement is for an administrative command, and the store is
        currently executing an administrative command that is the logical
        equivalent the action specified by the statement, the method will
        return a ExecutionFuture identifier that serves as a handle to that
        operation, rather than starting a new invocation of the command.
        The caller can use the ExecutionFuture identifier to wait for the
        completion of the administrative operation.


        Parameters:
         - statement
        """
        pass

    def executionFutureCancelV2(self, executionId, mayInterruptIfRunning):
        """
        Attempts to cancel execution of this statement. Return false if the
        statement couldn't be cancelled, possibly because it has already
        finished. If the statement hasn't succeeded already, and can be stopped,
        the operation will transition to the FAILED state.


        Parameters:
         - executionId
         - mayInterruptIfRunning
        """
        pass

    def executionFutureGetV2(self, executionId):
        """
        Blocks until the command represented by this future completes. Returns
        information about the execution of the statement. This call will result
        in communication with the kvstore server.


        Parameters:
         - executionId
        """
        pass

    def executionFutureGetTimeoutV2(self, executionId, timeoutMs):
        """
        Blocks until the administrative operation has finished or the timeout
        period is exceeded. This call will result in communication with the
        kvstore server.


        Parameters:
         - executionId
         - timeoutMs
        """
        pass

    def executionFutureUpdateStatusV2(self, executionId):
        """
        Returns information about the execution of the statement. If the
        statement is still executing, this call will result in communication
        with the kvstore server to obtain up to date status, and the status
        returned will reflect interim information.


        Parameters:
         - executionId
        """
        pass

    def executeUpdates(self, operations, writeOptions):
        """
        This method provides an efficient and transactional mechanism for
        executing a sequence of operations associated with tables that share
        the same shard key portion of their primary keys.


        Parameters:
         - operations
         - writeOptions
        """
        pass

    def getOptions(self):
        """
        gets all non-null option values indexed by option names.
        """
        pass


class Client(Iface):
    """
    KVProxy interface equivalent to kvclient TableAPI.

    """
    def __init__(self, iprot, oprot=None):
        self._iprot = self._oprot = iprot
        if oprot is not None:
            self._oprot = oprot
        self._seqid = 0

    def ping(self):
        """
        For checking that the KVProxy server is reachable. *
        """
        self.send_ping()
        self.recv_ping()

    def send_ping(self):
        self._oprot.writeMessageBegin('ping', TMessageType.CALL, self._seqid)
        args = ping_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_ping(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = ping_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def version(self, whichModule):
        """
        Returns the version string of each module. *

        Parameters:
         - whichModule
        """
        self.send_version(whichModule)
        return self.recv_version()

    def send_version(self, whichModule):
        self._oprot.writeMessageBegin('version', TMessageType.CALL, self._seqid)
        args = version_args()
        args.whichModule = whichModule
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_version(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = version_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "version failed: unknown result")

    def status(self, whichModule):
        """
        For checking the status of all the modules. *

        Parameters:
         - whichModule
        """
        self.send_status(whichModule)
        return self.recv_status()

    def send_status(self, whichModule):
        self._oprot.writeMessageBegin('status', TMessageType.CALL, self._seqid)
        args = status_args()
        args.whichModule = whichModule
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_status(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = status_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "status failed: unknown result")

    def shutdown(self):
        """
        Shuts down the proxy server if it's allowed *
        """
        self.send_shutdown()

    def send_shutdown(self):
        self._oprot.writeMessageBegin('shutdown', TMessageType.ONEWAY, self._seqid)
        args = shutdown_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def verify(self, properties):
        """
        Verifies the connection properties: kvstore, credentials, etc.
        The kvStoreHelperHosts list must have at least one entry and all entries
        must be contained in the list that the server was started with.

        Parameters:
         - properties
        """
        self.send_verify(properties)
        return self.recv_verify()

    def send_verify(self, properties):
        self._oprot.writeMessageBegin('verify', TMessageType.CALL, self._seqid)
        args = verify_args()
        args.properties = properties
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_verify(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = verify_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.uve is not None:
            raise result.uve
        raise TApplicationException(TApplicationException.MISSING_RESULT, "verify failed: unknown result")

    def put(self, tableName, row, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - writeOptions
        """
        self.send_put(tableName, row, writeOptions)
        return self.recv_put()

    def send_put(self, tableName, row, writeOptions):
        self._oprot.writeMessageBegin('put', TMessageType.CALL, self._seqid)
        args = put_args()
        args.tableName = tableName
        args.row = row
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_put(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = put_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "put failed: unknown result")

    def putIfAbsent(self, tableName, row, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - writeOptions
        """
        self.send_putIfAbsent(tableName, row, writeOptions)
        return self.recv_putIfAbsent()

    def send_putIfAbsent(self, tableName, row, writeOptions):
        self._oprot.writeMessageBegin('putIfAbsent', TMessageType.CALL, self._seqid)
        args = putIfAbsent_args()
        args.tableName = tableName
        args.row = row
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_putIfAbsent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = putIfAbsent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "putIfAbsent failed: unknown result")

    def putIfPresent(self, tableName, row, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - writeOptions
        """
        self.send_putIfPresent(tableName, row, writeOptions)
        return self.recv_putIfPresent()

    def send_putIfPresent(self, tableName, row, writeOptions):
        self._oprot.writeMessageBegin('putIfPresent', TMessageType.CALL, self._seqid)
        args = putIfPresent_args()
        args.tableName = tableName
        args.row = row
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_putIfPresent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = putIfPresent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "putIfPresent failed: unknown result")

    def putIfVersion(self, tableName, row, matchVersion, writeOptions):
        """
        Parameters:
         - tableName
         - row
         - matchVersion
         - writeOptions
        """
        self.send_putIfVersion(tableName, row, matchVersion, writeOptions)
        return self.recv_putIfVersion()

    def send_putIfVersion(self, tableName, row, matchVersion, writeOptions):
        self._oprot.writeMessageBegin('putIfVersion', TMessageType.CALL, self._seqid)
        args = putIfVersion_args()
        args.tableName = tableName
        args.row = row
        args.matchVersion = matchVersion
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_putIfVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = putIfVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "putIfVersion failed: unknown result")

    def get(self, tableName, key, readOptions):
        """
        Parameters:
         - tableName
         - key
         - readOptions
        """
        self.send_get(tableName, key, readOptions)
        return self.recv_get()

    def send_get(self, tableName, key, readOptions):
        self._oprot.writeMessageBegin('get', TMessageType.CALL, self._seqid)
        args = get_args()
        args.tableName = tableName
        args.key = key
        args.readOptions = readOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.ce is not None:
            raise result.ce
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get failed: unknown result")

    def deleteRow(self, tableName, key, writeOptions):
        """
        Parameters:
         - tableName
         - key
         - writeOptions
        """
        self.send_deleteRow(tableName, key, writeOptions)
        return self.recv_deleteRow()

    def send_deleteRow(self, tableName, key, writeOptions):
        self._oprot.writeMessageBegin('deleteRow', TMessageType.CALL, self._seqid)
        args = deleteRow_args()
        args.tableName = tableName
        args.key = key
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteRow(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteRow_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteRow failed: unknown result")

    def deleteRowIfVersion(self, tableName, key, matchVersion, writeOptions):
        """
        Parameters:
         - tableName
         - key
         - matchVersion
         - writeOptions
        """
        self.send_deleteRowIfVersion(tableName, key, matchVersion, writeOptions)
        return self.recv_deleteRowIfVersion()

    def send_deleteRowIfVersion(self, tableName, key, matchVersion, writeOptions):
        self._oprot.writeMessageBegin('deleteRowIfVersion', TMessageType.CALL, self._seqid)
        args = deleteRowIfVersion_args()
        args.tableName = tableName
        args.key = key
        args.matchVersion = matchVersion
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_deleteRowIfVersion(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = deleteRowIfVersion_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "deleteRowIfVersion failed: unknown result")

    def multiDelete(self, tableName, key, fieldRange, includedTable, writeOptions):
        """
        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTable
         - writeOptions
        """
        self.send_multiDelete(tableName, key, fieldRange, includedTable, writeOptions)
        return self.recv_multiDelete()

    def send_multiDelete(self, tableName, key, fieldRange, includedTable, writeOptions):
        self._oprot.writeMessageBegin('multiDelete', TMessageType.CALL, self._seqid)
        args = multiDelete_args()
        args.tableName = tableName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTable = includedTable
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_multiDelete(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = multiDelete_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "multiDelete failed: unknown result")

    def multiGet(self, tableName, key, fieldRange, includedTables, readOptions):
        """
        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
        """
        self.send_multiGet(tableName, key, fieldRange, includedTables, readOptions)
        return self.recv_multiGet()

    def send_multiGet(self, tableName, key, fieldRange, includedTables, readOptions):
        self._oprot.writeMessageBegin('multiGet', TMessageType.CALL, self._seqid)
        args = multiGet_args()
        args.tableName = tableName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_multiGet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = multiGet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "multiGet failed: unknown result")

    def multiGetKeys(self, tableName, key, fieldRange, includedTables, readOptions):
        """
        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
        """
        self.send_multiGetKeys(tableName, key, fieldRange, includedTables, readOptions)
        return self.recv_multiGetKeys()

    def send_multiGetKeys(self, tableName, key, fieldRange, includedTables, readOptions):
        self._oprot.writeMessageBegin('multiGetKeys', TMessageType.CALL, self._seqid)
        args = multiGetKeys_args()
        args.tableName = tableName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_multiGetKeys(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = multiGetKeys_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        raise TApplicationException(TApplicationException.MISSING_RESULT, "multiGetKeys failed: unknown result")

    def tableIterator(self, tableName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value is used.


        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        self.send_tableIterator(tableName, key, fieldRange, includedTables, readOptions, direction, maxResults)
        return self.recv_tableIterator()

    def send_tableIterator(self, tableName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        self._oprot.writeMessageBegin('tableIterator', TMessageType.CALL, self._seqid)
        args = tableIterator_args()
        args.tableName = tableName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.direction = direction
        args.maxResults = maxResults
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.ite is not None:
            raise result.ite
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIterator failed: unknown result")

    def tableIteratorMulti(self, tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint):
        """
        Returns an iterator over the rows matching the primary keys supplied
        (or the rows in ancestor or descendant tables, or those in a
        range specified by the MultiRowOptions argument).

        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value is used.

        @param numParallelIterHint this is a hint that might be used for
        optimizing performance.

        @since version 3


        Parameters:
         - tableName
         - keys
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
         - numParallelIterHint
        """
        self.send_tableIteratorMulti(tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint)
        return self.recv_tableIteratorMulti()

    def send_tableIteratorMulti(self, tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint):
        self._oprot.writeMessageBegin('tableIteratorMulti', TMessageType.CALL, self._seqid)
        args = tableIteratorMulti_args()
        args.tableName = tableName
        args.keys = keys
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.direction = direction
        args.maxResults = maxResults
        args.numParallelIterHint = numParallelIterHint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableIteratorMulti(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableIteratorMulti_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.ite is not None:
            raise result.ite
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableIteratorMulti failed: unknown result")

    def iteratorNext(self, iteratorId):
        """
        The number of rows in result is linked to the maxResult when the
        iterator was created.


        Parameters:
         - iteratorId
        """
        self.send_iteratorNext(iteratorId)
        return self.recv_iteratorNext()

    def send_iteratorNext(self, iteratorId):
        self._oprot.writeMessageBegin('iteratorNext', TMessageType.CALL, self._seqid)
        args = iteratorNext_args()
        args.iteratorId = iteratorId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_iteratorNext(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = iteratorNext_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.ite is not None:
            raise result.ite
        raise TApplicationException(TApplicationException.MISSING_RESULT, "iteratorNext failed: unknown result")

    def iteratorClose(self, iteratorId):
        """
        There is no need to close an iterator if the last TIteratorResult
        returned contained hasMore == false.


        Parameters:
         - iteratorId
        """
        self.send_iteratorClose(iteratorId)
        self.recv_iteratorClose()

    def send_iteratorClose(self, iteratorId):
        self._oprot.writeMessageBegin('iteratorClose', TMessageType.CALL, self._seqid)
        args = iteratorClose_args()
        args.iteratorId = iteratorId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_iteratorClose(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = iteratorClose_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def tableKeyIterator(self, tableName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value.


        Parameters:
         - tableName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        self.send_tableKeyIterator(tableName, key, fieldRange, includedTables, readOptions, direction, maxResults)
        return self.recv_tableKeyIterator()

    def send_tableKeyIterator(self, tableName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        self._oprot.writeMessageBegin('tableKeyIterator', TMessageType.CALL, self._seqid)
        args = tableKeyIterator_args()
        args.tableName = tableName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.direction = direction
        args.maxResults = maxResults
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableKeyIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableKeyIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.tie is not None:
            raise result.tie
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableKeyIterator failed: unknown result")

    def tableKeyIteratorMulti(self, tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint):
        """
        Returns an iterator over the keys matching the primary keys supplied by
        iterator (or the rows in ancestor or descendant tables, or those in a
        range specified by the MultiRowOptions argument).

        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value.

        @param numParallelIterHint this is a hint that might be used for
        optimizing performance.

        @since version 3


        Parameters:
         - tableName
         - keys
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
         - numParallelIterHint
        """
        self.send_tableKeyIteratorMulti(tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint)
        return self.recv_tableKeyIteratorMulti()

    def send_tableKeyIteratorMulti(self, tableName, keys, fieldRange, includedTables, readOptions, direction, maxResults, numParallelIterHint):
        self._oprot.writeMessageBegin('tableKeyIteratorMulti', TMessageType.CALL, self._seqid)
        args = tableKeyIteratorMulti_args()
        args.tableName = tableName
        args.keys = keys
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.direction = direction
        args.maxResults = maxResults
        args.numParallelIterHint = numParallelIterHint
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_tableKeyIteratorMulti(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = tableKeyIteratorMulti_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.tie is not None:
            raise result.tie
        raise TApplicationException(TApplicationException.MISSING_RESULT, "tableKeyIteratorMulti failed: unknown result")

    def indexIterator(self, tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value or
        -max-iterator-results configured value.


        Parameters:
         - tableName
         - indexName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        self.send_indexIterator(tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults)
        return self.recv_indexIterator()

    def send_indexIterator(self, tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        self._oprot.writeMessageBegin('indexIterator', TMessageType.CALL, self._seqid)
        args = indexIterator_args()
        args.tableName = tableName
        args.indexName = indexName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.direction = direction
        args.maxResults = maxResults
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_indexIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = indexIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.ite is not None:
            raise result.ite
        raise TApplicationException(TApplicationException.MISSING_RESULT, "indexIterator failed: unknown result")

    def indexKeyIterator(self, tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        """
        indexKeyIterator returns column values that are part of both the
        primary key and the index key.
        @param maxResults Represents the maximum expected number of rows in
        the result. The number of rows can be smaller than MaxResults but not
        bigger. If maxResults is less than 1, the default value is used.


        Parameters:
         - tableName
         - indexName
         - key
         - fieldRange
         - includedTables
         - readOptions
         - direction
         - maxResults
        """
        self.send_indexKeyIterator(tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults)
        return self.recv_indexKeyIterator()

    def send_indexKeyIterator(self, tableName, indexName, key, fieldRange, includedTables, readOptions, direction, maxResults):
        self._oprot.writeMessageBegin('indexKeyIterator', TMessageType.CALL, self._seqid)
        args = indexKeyIterator_args()
        args.tableName = tableName
        args.indexName = indexName
        args.key = key
        args.fieldRange = fieldRange
        args.includedTables = includedTables
        args.readOptions = readOptions
        args.direction = direction
        args.maxResults = maxResults
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_indexKeyIterator(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = indexKeyIterator_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.re is not None:
            raise result.re
        if result.fe is not None:
            raise result.fe
        if result.pe is not None:
            raise result.pe
        if result.iae is not None:
            raise result.iae
        if result.ite is not None:
            raise result.ite
        raise TApplicationException(TApplicationException.MISSING_RESULT, "indexKeyIterator failed: unknown result")

    def refreshTables(self):
        """
        Refreshes cached information about the tables. This method is
        required before using any tables that had been modified.

        """
        self.send_refreshTables()
        self.recv_refreshTables()

    def send_refreshTables(self):
        self._oprot.writeMessageBegin('refreshTables', TMessageType.CALL, self._seqid)
        args = refreshTables_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_refreshTables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = refreshTables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.fe is not None:
            raise result.fe
        return

    def executeSync(self, statement):
        """
        Synchronously execute a table statement. The method will only return
        when the statement has finished. Has the same semantics as
        execute(String), but offers synchronous behaviour as a convenience.

        @Deprecated This method is replaced by #executeSyncV2 in
        protocol version 2.


        Parameters:
         - statement
        """
        self.send_executeSync(statement)
        return self.recv_executeSync()

    def send_executeSync(self, statement):
        self._oprot.writeMessageBegin('executeSync', TMessageType.CALL, self._seqid)
        args = executeSync_args()
        args.statement = statement
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeSync(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeSync_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.ise is not None:
            raise result.ise
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executeSync failed: unknown result")

    def execute(self, statement):
        """
        Asynchronously executes a table statement. Currently, table statements
        can be used to create or modify tables and indices. The operation is
        asynchronous and may not be finished when the method returns.

        A ExecutionFuture identifier (planId) is returned and can be used to get
        information about the status of the operation, or to await completion
        of the operation.

        If the statement is for an administrative command, and the store is
        currently executing an administrative command that is the logical
        equivalent the action specified by the statement, the method will
        return a ExecutionFuture identifier that serves as a handle to that
        operation, rather than starting a new invocation of the command.
        The caller can use the ExecutionFuture identifier to wait for the
        completion of the administrative operation.

        @Deprecated This method is replaced by #executeV2 in
        protocol version 2.


        Parameters:
         - statement
        """
        self.send_execute(statement)
        return self.recv_execute()

    def send_execute(self, statement):
        self._oprot.writeMessageBegin('execute', TMessageType.CALL, self._seqid)
        args = execute_args()
        args.statement = statement
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_execute(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = execute_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "execute failed: unknown result")

    def executionFutureCancel(self, planId, mayInterruptIfRunning):
        """
        Attempts to cancel execution of this statement. Return false if the
        statement couldn't be cancelled, possibly because it has already
        finished. If the statement hasn't succeeded already, and can be stopped,
        the operation will transition to the FAILED state.

        @Deprecated This method is replaced by #executionFutureCancelV2 in
        protocol version 2.


        Parameters:
         - planId
         - mayInterruptIfRunning
        """
        self.send_executionFutureCancel(planId, mayInterruptIfRunning)
        return self.recv_executionFutureCancel()

    def send_executionFutureCancel(self, planId, mayInterruptIfRunning):
        self._oprot.writeMessageBegin('executionFutureCancel', TMessageType.CALL, self._seqid)
        args = executionFutureCancel_args()
        args.planId = planId
        args.mayInterruptIfRunning = mayInterruptIfRunning
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureCancel(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureCancel_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureCancel failed: unknown result")

    def executionFutureGet(self, planId):
        """
        Blocks until the command represented by this future completes. Returns
        information about the execution of the statement. This call will result
        in communication with the kvstore server.

        @Deprecated This method is replaced by #executionFutureGetV2 in
        protocol version 2.


        Parameters:
         - planId
        """
        self.send_executionFutureGet(planId)
        return self.recv_executionFutureGet()

    def send_executionFutureGet(self, planId):
        self._oprot.writeMessageBegin('executionFutureGet', TMessageType.CALL, self._seqid)
        args = executionFutureGet_args()
        args.planId = planId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureGet(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureGet_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.ce is not None:
            raise result.ce
        if result.ee is not None:
            raise result.ee
        if result.ie is not None:
            raise result.ie
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureGet failed: unknown result")

    def executionFutureGetTimeout(self, planId, timeoutMs):
        """
        Blocks until the administrative operation has finished or the timeout
        period is exceeded. This call will result in communication with the
        kvstore server.

        @Deprecated This method is replaced by #executionFutureTimeoutV2 in
        protocol version 2.


        Parameters:
         - planId
         - timeoutMs
        """
        self.send_executionFutureGetTimeout(planId, timeoutMs)
        return self.recv_executionFutureGetTimeout()

    def send_executionFutureGetTimeout(self, planId, timeoutMs):
        self._oprot.writeMessageBegin('executionFutureGetTimeout', TMessageType.CALL, self._seqid)
        args = executionFutureGetTimeout_args()
        args.planId = planId
        args.timeoutMs = timeoutMs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureGetTimeout(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureGetTimeout_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.ie is not None:
            raise result.ie
        if result.te is not None:
            raise result.te
        if result.ee is not None:
            raise result.ee
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureGetTimeout failed: unknown result")

    def executionFutureUpdateStatus(self, planId):
        """
        Returns information about the execution of the statement. If the
        statement is still executing, this call will result in communication
        with the kvstore server to obtain up to date status, and the status
        returned will reflect interim information.

        @Deprecated This method is replaced by #executionFutureUpdateStatusV2
         in protocol version 2.


        Parameters:
         - planId
        """
        self.send_executionFutureUpdateStatus(planId)
        return self.recv_executionFutureUpdateStatus()

    def send_executionFutureUpdateStatus(self, planId):
        self._oprot.writeMessageBegin('executionFutureUpdateStatus', TMessageType.CALL, self._seqid)
        args = executionFutureUpdateStatus_args()
        args.planId = planId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureUpdateStatus(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureUpdateStatus_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureUpdateStatus failed: unknown result")

    def executeSyncV2(self, statement):
        """
        Synchronously execute a table statement. The method will only return
        when the statement has finished. Has the same semantics as
        executeV2(String), but offers synchronous behaviour as a convenience.


        Parameters:
         - statement
        """
        self.send_executeSyncV2(statement)
        return self.recv_executeSyncV2()

    def send_executeSyncV2(self, statement):
        self._oprot.writeMessageBegin('executeSyncV2', TMessageType.CALL, self._seqid)
        args = executeSyncV2_args()
        args.statement = statement
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeSyncV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeSyncV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.ise is not None:
            raise result.ise
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executeSyncV2 failed: unknown result")

    def executeV2(self, statement):
        """
        Asynchronously executes a table statement. Currently, table statements
        can be used to create or modify tables and indices. The operation is
        asynchronous and may not be finished when the method returns.

        A ExecutionFuture identifier is returned and can be later used to get
        information about the status of the operation, cancel or to await
        completion of the operation.

        If the statement is for an administrative command, and the store is
        currently executing an administrative command that is the logical
        equivalent the action specified by the statement, the method will
        return a ExecutionFuture identifier that serves as a handle to that
        operation, rather than starting a new invocation of the command.
        The caller can use the ExecutionFuture identifier to wait for the
        completion of the administrative operation.


        Parameters:
         - statement
        """
        self.send_executeV2(statement)
        return self.recv_executeV2()

    def send_executeV2(self, statement):
        self._oprot.writeMessageBegin('executeV2', TMessageType.CALL, self._seqid)
        args = executeV2_args()
        args.statement = statement
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executeV2 failed: unknown result")

    def executionFutureCancelV2(self, executionId, mayInterruptIfRunning):
        """
        Attempts to cancel execution of this statement. Return false if the
        statement couldn't be cancelled, possibly because it has already
        finished. If the statement hasn't succeeded already, and can be stopped,
        the operation will transition to the FAILED state.


        Parameters:
         - executionId
         - mayInterruptIfRunning
        """
        self.send_executionFutureCancelV2(executionId, mayInterruptIfRunning)
        return self.recv_executionFutureCancelV2()

    def send_executionFutureCancelV2(self, executionId, mayInterruptIfRunning):
        self._oprot.writeMessageBegin('executionFutureCancelV2', TMessageType.CALL, self._seqid)
        args = executionFutureCancelV2_args()
        args.executionId = executionId
        args.mayInterruptIfRunning = mayInterruptIfRunning
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureCancelV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureCancelV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureCancelV2 failed: unknown result")

    def executionFutureGetV2(self, executionId):
        """
        Blocks until the command represented by this future completes. Returns
        information about the execution of the statement. This call will result
        in communication with the kvstore server.


        Parameters:
         - executionId
        """
        self.send_executionFutureGetV2(executionId)
        return self.recv_executionFutureGetV2()

    def send_executionFutureGetV2(self, executionId):
        self._oprot.writeMessageBegin('executionFutureGetV2', TMessageType.CALL, self._seqid)
        args = executionFutureGetV2_args()
        args.executionId = executionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureGetV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureGetV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.ce is not None:
            raise result.ce
        if result.ee is not None:
            raise result.ee
        if result.ie is not None:
            raise result.ie
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureGetV2 failed: unknown result")

    def executionFutureGetTimeoutV2(self, executionId, timeoutMs):
        """
        Blocks until the administrative operation has finished or the timeout
        period is exceeded. This call will result in communication with the
        kvstore server.


        Parameters:
         - executionId
         - timeoutMs
        """
        self.send_executionFutureGetTimeoutV2(executionId, timeoutMs)
        return self.recv_executionFutureGetTimeoutV2()

    def send_executionFutureGetTimeoutV2(self, executionId, timeoutMs):
        self._oprot.writeMessageBegin('executionFutureGetTimeoutV2', TMessageType.CALL, self._seqid)
        args = executionFutureGetTimeoutV2_args()
        args.executionId = executionId
        args.timeoutMs = timeoutMs
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureGetTimeoutV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureGetTimeoutV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.ie is not None:
            raise result.ie
        if result.te is not None:
            raise result.te
        if result.ee is not None:
            raise result.ee
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureGetTimeoutV2 failed: unknown result")

    def executionFutureUpdateStatusV2(self, executionId):
        """
        Returns information about the execution of the statement. If the
        statement is still executing, this call will result in communication
        with the kvstore server to obtain up to date status, and the status
        returned will reflect interim information.


        Parameters:
         - executionId
        """
        self.send_executionFutureUpdateStatusV2(executionId)
        return self.recv_executionFutureUpdateStatusV2()

    def send_executionFutureUpdateStatusV2(self, executionId):
        self._oprot.writeMessageBegin('executionFutureUpdateStatusV2', TMessageType.CALL, self._seqid)
        args = executionFutureUpdateStatusV2_args()
        args.executionId = executionId
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executionFutureUpdateStatusV2(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executionFutureUpdateStatusV2_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executionFutureUpdateStatusV2 failed: unknown result")

    def executeUpdates(self, operations, writeOptions):
        """
        This method provides an efficient and transactional mechanism for
        executing a sequence of operations associated with tables that share
        the same shard key portion of their primary keys.


        Parameters:
         - operations
         - writeOptions
        """
        self.send_executeUpdates(operations, writeOptions)
        return self.recv_executeUpdates()

    def send_executeUpdates(self, operations, writeOptions):
        self._oprot.writeMessageBegin('executeUpdates', TMessageType.CALL, self._seqid)
        args = executeUpdates_args()
        args.operations = operations
        args.writeOptions = writeOptions
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_executeUpdates(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = executeUpdates_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.de is not None:
            raise result.de
        if result.toee is not None:
            raise result.toee
        if result.fe is not None:
            raise result.fe
        if result.iae is not None:
            raise result.iae
        if result.pe is not None:
            raise result.pe
        raise TApplicationException(TApplicationException.MISSING_RESULT, "executeUpdates failed: unknown result")

    def getOptions(self):
        """
        gets all non-null option values indexed by option names.
        """
        self.send_getOptions()
        return self.recv_getOptions()

    def send_getOptions(self):
        self._oprot.writeMessageBegin('getOptions', TMessageType.CALL, self._seqid)
        args = getOptions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getOptions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getOptions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getOptions failed: unknown result")


class Processor(Iface, TProcessor):
    def __init__(self, handler):
        self._handler = handler
        self._processMap = {}
        self._processMap["ping"] = Processor.process_ping
        self._processMap["version"] = Processor.process_version
        self._processMap["status"] = Processor.process_status
        self._processMap["shutdown"] = Processor.process_shutdown
        self._processMap["verify"] = Processor.process_verify
        self._processMap["put"] = Processor.process_put
        self._processMap["putIfAbsent"] = Processor.process_putIfAbsent
        self._processMap["putIfPresent"] = Processor.process_putIfPresent
        self._processMap["putIfVersion"] = Processor.process_putIfVersion
        self._processMap["get"] = Processor.process_get
        self._processMap["deleteRow"] = Processor.process_deleteRow
        self._processMap["deleteRowIfVersion"] = Processor.process_deleteRowIfVersion
        self._processMap["multiDelete"] = Processor.process_multiDelete
        self._processMap["multiGet"] = Processor.process_multiGet
        self._processMap["multiGetKeys"] = Processor.process_multiGetKeys
        self._processMap["tableIterator"] = Processor.process_tableIterator
        self._processMap["tableIteratorMulti"] = Processor.process_tableIteratorMulti
        self._processMap["iteratorNext"] = Processor.process_iteratorNext
        self._processMap["iteratorClose"] = Processor.process_iteratorClose
        self._processMap["tableKeyIterator"] = Processor.process_tableKeyIterator
        self._processMap["tableKeyIteratorMulti"] = Processor.process_tableKeyIteratorMulti
        self._processMap["indexIterator"] = Processor.process_indexIterator
        self._processMap["indexKeyIterator"] = Processor.process_indexKeyIterator
        self._processMap["refreshTables"] = Processor.process_refreshTables
        self._processMap["executeSync"] = Processor.process_executeSync
        self._processMap["execute"] = Processor.process_execute
        self._processMap["executionFutureCancel"] = Processor.process_executionFutureCancel
        self._processMap["executionFutureGet"] = Processor.process_executionFutureGet
        self._processMap["executionFutureGetTimeout"] = Processor.process_executionFutureGetTimeout
        self._processMap["executionFutureUpdateStatus"] = Processor.process_executionFutureUpdateStatus
        self._processMap["executeSyncV2"] = Processor.process_executeSyncV2
        self._processMap["executeV2"] = Processor.process_executeV2
        self._processMap["executionFutureCancelV2"] = Processor.process_executionFutureCancelV2
        self._processMap["executionFutureGetV2"] = Processor.process_executionFutureGetV2
        self._processMap["executionFutureGetTimeoutV2"] = Processor.process_executionFutureGetTimeoutV2
        self._processMap["executionFutureUpdateStatusV2"] = Processor.process_executionFutureUpdateStatusV2
        self._processMap["executeUpdates"] = Processor.process_executeUpdates
        self._processMap["getOptions"] = Processor.process_getOptions

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_ping(self, seqid, iprot, oprot):
        args = ping_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = ping_result()
        try:
            self._handler.ping()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("ping", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_version(self, seqid, iprot, oprot):
        args = version_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = version_result()
        try:
            result.success = self._handler.version(args.whichModule)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("version", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_status(self, seqid, iprot, oprot):
        args = status_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = status_result()
        try:
            result.success = self._handler.status(args.whichModule)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("status", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_shutdown(self, seqid, iprot, oprot):
        args = shutdown_args()
        args.read(iprot)
        iprot.readMessageEnd()
        try:
            self._handler.shutdown()
        except TTransport.TTransportException:
            raise
        except Exception:
            logging.exception('Exception in oneway handler')

    def process_verify(self, seqid, iprot, oprot):
        args = verify_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = verify_result()
        try:
            result.success = self._handler.verify(args.properties)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TUnverifiedConnectionException as uve:
            msg_type = TMessageType.REPLY
            result.uve = uve
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("verify", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_put(self, seqid, iprot, oprot):
        args = put_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = put_result()
        try:
            result.success = self._handler.put(args.tableName, args.row, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("put", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putIfAbsent(self, seqid, iprot, oprot):
        args = putIfAbsent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = putIfAbsent_result()
        try:
            result.success = self._handler.putIfAbsent(args.tableName, args.row, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("putIfAbsent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putIfPresent(self, seqid, iprot, oprot):
        args = putIfPresent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = putIfPresent_result()
        try:
            result.success = self._handler.putIfPresent(args.tableName, args.row, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("putIfPresent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_putIfVersion(self, seqid, iprot, oprot):
        args = putIfVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = putIfVersion_result()
        try:
            result.success = self._handler.putIfVersion(args.tableName, args.row, args.matchVersion, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("putIfVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get(self, seqid, iprot, oprot):
        args = get_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_result()
        try:
            result.success = self._handler.get(args.tableName, args.key, args.readOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteRow(self, seqid, iprot, oprot):
        args = deleteRow_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteRow_result()
        try:
            result.success = self._handler.deleteRow(args.tableName, args.key, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteRow", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_deleteRowIfVersion(self, seqid, iprot, oprot):
        args = deleteRowIfVersion_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = deleteRowIfVersion_result()
        try:
            result.success = self._handler.deleteRowIfVersion(args.tableName, args.key, args.matchVersion, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("deleteRowIfVersion", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_multiDelete(self, seqid, iprot, oprot):
        args = multiDelete_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = multiDelete_result()
        try:
            result.success = self._handler.multiDelete(args.tableName, args.key, args.fieldRange, args.includedTable, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("multiDelete", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_multiGet(self, seqid, iprot, oprot):
        args = multiGet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = multiGet_result()
        try:
            result.success = self._handler.multiGet(args.tableName, args.key, args.fieldRange, args.includedTables, args.readOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("multiGet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_multiGetKeys(self, seqid, iprot, oprot):
        args = multiGetKeys_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = multiGetKeys_result()
        try:
            result.success = self._handler.multiGetKeys(args.tableName, args.key, args.fieldRange, args.includedTables, args.readOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("multiGetKeys", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableIterator(self, seqid, iprot, oprot):
        args = tableIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableIterator_result()
        try:
            result.success = self._handler.tableIterator(args.tableName, args.key, args.fieldRange, args.includedTables, args.readOptions, args.direction, args.maxResults)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as ite:
            msg_type = TMessageType.REPLY
            result.ite = ite
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tableIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableIteratorMulti(self, seqid, iprot, oprot):
        args = tableIteratorMulti_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableIteratorMulti_result()
        try:
            result.success = self._handler.tableIteratorMulti(args.tableName, args.keys, args.fieldRange, args.includedTables, args.readOptions, args.direction, args.maxResults, args.numParallelIterHint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as ite:
            msg_type = TMessageType.REPLY
            result.ite = ite
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tableIteratorMulti", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_iteratorNext(self, seqid, iprot, oprot):
        args = iteratorNext_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = iteratorNext_result()
        try:
            result.success = self._handler.iteratorNext(args.iteratorId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as ite:
            msg_type = TMessageType.REPLY
            result.ite = ite
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("iteratorNext", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_iteratorClose(self, seqid, iprot, oprot):
        args = iteratorClose_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = iteratorClose_result()
        try:
            self._handler.iteratorClose(args.iteratorId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("iteratorClose", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableKeyIterator(self, seqid, iprot, oprot):
        args = tableKeyIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableKeyIterator_result()
        try:
            result.success = self._handler.tableKeyIterator(args.tableName, args.key, args.fieldRange, args.includedTables, args.readOptions, args.direction, args.maxResults)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as tie:
            msg_type = TMessageType.REPLY
            result.tie = tie
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tableKeyIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_tableKeyIteratorMulti(self, seqid, iprot, oprot):
        args = tableKeyIteratorMulti_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = tableKeyIteratorMulti_result()
        try:
            result.success = self._handler.tableKeyIteratorMulti(args.tableName, args.keys, args.fieldRange, args.includedTables, args.readOptions, args.direction, args.maxResults, args.numParallelIterHint)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as tie:
            msg_type = TMessageType.REPLY
            result.tie = tie
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("tableKeyIteratorMulti", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_indexIterator(self, seqid, iprot, oprot):
        args = indexIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = indexIterator_result()
        try:
            result.success = self._handler.indexIterator(args.tableName, args.indexName, args.key, args.fieldRange, args.includedTables, args.readOptions, args.direction, args.maxResults)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as ite:
            msg_type = TMessageType.REPLY
            result.ite = ite
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("indexIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_indexKeyIterator(self, seqid, iprot, oprot):
        args = indexKeyIterator_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = indexKeyIterator_result()
        try:
            result.success = self._handler.indexKeyIterator(args.tableName, args.indexName, args.key, args.fieldRange, args.includedTables, args.readOptions, args.direction, args.maxResults)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TConsistencyException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TRequestTimeoutException as re:
            msg_type = TMessageType.REPLY
            result.re = re
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TIteratorTimeoutException as ite:
            msg_type = TMessageType.REPLY
            result.ite = ite
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("indexKeyIterator", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_refreshTables(self, seqid, iprot, oprot):
        args = refreshTables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = refreshTables_result()
        try:
            self._handler.refreshTables()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("refreshTables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeSync(self, seqid, iprot, oprot):
        args = executeSync_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeSync_result()
        try:
            result.success = self._handler.executeSync(args.statement)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as ise:
            msg_type = TMessageType.REPLY
            result.ise = ise
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeSync", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_execute(self, seqid, iprot, oprot):
        args = execute_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = execute_result()
        try:
            result.success = self._handler.execute(args.statement)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("execute", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureCancel(self, seqid, iprot, oprot):
        args = executionFutureCancel_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureCancel_result()
        try:
            result.success = self._handler.executionFutureCancel(args.planId, args.mayInterruptIfRunning)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureCancel", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureGet(self, seqid, iprot, oprot):
        args = executionFutureGet_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureGet_result()
        try:
            result.success = self._handler.executionFutureGet(args.planId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TCancellationException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TExecutionException as ee:
            msg_type = TMessageType.REPLY
            result.ee = ee
        except TInterruptedException as ie:
            msg_type = TMessageType.REPLY
            result.ie = ie
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureGet", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureGetTimeout(self, seqid, iprot, oprot):
        args = executionFutureGetTimeout_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureGetTimeout_result()
        try:
            result.success = self._handler.executionFutureGetTimeout(args.planId, args.timeoutMs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TInterruptedException as ie:
            msg_type = TMessageType.REPLY
            result.ie = ie
        except TTimeoutException as te:
            msg_type = TMessageType.REPLY
            result.te = te
        except TExecutionException as ee:
            msg_type = TMessageType.REPLY
            result.ee = ee
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureGetTimeout", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureUpdateStatus(self, seqid, iprot, oprot):
        args = executionFutureUpdateStatus_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureUpdateStatus_result()
        try:
            result.success = self._handler.executionFutureUpdateStatus(args.planId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureUpdateStatus", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeSyncV2(self, seqid, iprot, oprot):
        args = executeSyncV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeSyncV2_result()
        try:
            result.success = self._handler.executeSyncV2(args.statement)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as ise:
            msg_type = TMessageType.REPLY
            result.ise = ise
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeSyncV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeV2(self, seqid, iprot, oprot):
        args = executeV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeV2_result()
        try:
            result.success = self._handler.executeV2(args.statement)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureCancelV2(self, seqid, iprot, oprot):
        args = executionFutureCancelV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureCancelV2_result()
        try:
            result.success = self._handler.executionFutureCancelV2(args.executionId, args.mayInterruptIfRunning)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureCancelV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureGetV2(self, seqid, iprot, oprot):
        args = executionFutureGetV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureGetV2_result()
        try:
            result.success = self._handler.executionFutureGetV2(args.executionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TCancellationException as ce:
            msg_type = TMessageType.REPLY
            result.ce = ce
        except TExecutionException as ee:
            msg_type = TMessageType.REPLY
            result.ee = ee
        except TInterruptedException as ie:
            msg_type = TMessageType.REPLY
            result.ie = ie
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureGetV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureGetTimeoutV2(self, seqid, iprot, oprot):
        args = executionFutureGetTimeoutV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureGetTimeoutV2_result()
        try:
            result.success = self._handler.executionFutureGetTimeoutV2(args.executionId, args.timeoutMs)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TInterruptedException as ie:
            msg_type = TMessageType.REPLY
            result.ie = ie
        except TTimeoutException as te:
            msg_type = TMessageType.REPLY
            result.te = te
        except TExecutionException as ee:
            msg_type = TMessageType.REPLY
            result.ee = ee
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureGetTimeoutV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executionFutureUpdateStatusV2(self, seqid, iprot, oprot):
        args = executionFutureUpdateStatusV2_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executionFutureUpdateStatusV2_result()
        try:
            result.success = self._handler.executionFutureUpdateStatusV2(args.executionId)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executionFutureUpdateStatusV2", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_executeUpdates(self, seqid, iprot, oprot):
        args = executeUpdates_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = executeUpdates_result()
        try:
            result.success = self._handler.executeUpdates(args.operations, args.writeOptions)
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TDurabilityException as de:
            msg_type = TMessageType.REPLY
            result.de = de
        except TTableOpExecutionException as toee:
            msg_type = TMessageType.REPLY
            result.toee = toee
        except TFaultException as fe:
            msg_type = TMessageType.REPLY
            result.fe = fe
        except TIllegalArgumentException as iae:
            msg_type = TMessageType.REPLY
            result.iae = iae
        except TProxyException as pe:
            msg_type = TMessageType.REPLY
            result.pe = pe
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("executeUpdates", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_getOptions(self, seqid, iprot, oprot):
        args = getOptions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getOptions_result()
        try:
            result.success = self._handler.getOptions()
            msg_type = TMessageType.REPLY
        except TTransport.TTransportException:
            raise
        except TApplicationException as ex:
            logging.exception('TApplication exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = ex
        except Exception:
            logging.exception('Unexpected exception in handler')
            msg_type = TMessageType.EXCEPTION
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getOptions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class ping_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_args)
ping_args.thrift_spec = (
)


class ping_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('ping_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(ping_result)
ping_result.thrift_spec = (
)


class version_args(object):
    """
    Attributes:
     - whichModule
    """


    def __init__(self, whichModule=None,):
        self.whichModule = whichModule

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.whichModule = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('version_args')
        if self.whichModule is not None:
            oprot.writeFieldBegin('whichModule', TType.I32, 1)
            oprot.writeI32(self.whichModule)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(version_args)
version_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'whichModule', None, None, ),  # 1
)


class version_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('version_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(version_result)
version_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class status_args(object):
    """
    Attributes:
     - whichModule
    """


    def __init__(self, whichModule=None,):
        self.whichModule = whichModule

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.whichModule = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('status_args')
        if self.whichModule is not None:
            oprot.writeFieldBegin('whichModule', TType.I32, 1)
            oprot.writeI32(self.whichModule)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(status_args)
status_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'whichModule', None, None, ),  # 1
)


class status_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('status_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(status_result)
status_result.thrift_spec = (
    (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
)


class shutdown_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('shutdown_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(shutdown_args)
shutdown_args.thrift_spec = (
)


class verify_args(object):
    """
    Attributes:
     - properties
    """


    def __init__(self, properties=None,):
        self.properties = properties

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.properties = TVerifyProperties()
                    self.properties.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_args')
        if self.properties is not None:
            oprot.writeFieldBegin('properties', TType.STRUCT, 1)
            self.properties.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_args)
verify_args.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'properties', [TVerifyProperties, None], None, ),  # 1
)


class verify_result(object):
    """
    Attributes:
     - success
     - uve
    """


    def __init__(self, success=None, uve=None,):
        self.success = success
        self.uve = uve

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TVerifyResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.uve = TUnverifiedConnectionException()
                    self.uve.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('verify_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.uve is not None:
            oprot.writeFieldBegin('uve', TType.STRUCT, 1)
            self.uve.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(verify_result)
verify_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TVerifyResult, None], None, ),  # 0
    (1, TType.STRUCT, 'uve', [TUnverifiedConnectionException, None], None, ),  # 1
)


class put_args(object):
    """
    Attributes:
     - tableName
     - row
     - writeOptions
    """


    def __init__(self, tableName=None, row=None, writeOptions=None,):
        self.tableName = tableName
        self.row = row
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.row = TRow()
                    self.row.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('put_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRUCT, 2)
            self.row.write(oprot)
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 3)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(put_args)
put_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'row', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 3
)


class put_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TWriteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('put_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(put_result)
put_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TWriteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class putIfAbsent_args(object):
    """
    Attributes:
     - tableName
     - row
     - writeOptions
    """


    def __init__(self, tableName=None, row=None, writeOptions=None,):
        self.tableName = tableName
        self.row = row
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.row = TRow()
                    self.row.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putIfAbsent_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRUCT, 2)
            self.row.write(oprot)
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 3)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putIfAbsent_args)
putIfAbsent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'row', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 3
)


class putIfAbsent_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TWriteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putIfAbsent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putIfAbsent_result)
putIfAbsent_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TWriteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class putIfPresent_args(object):
    """
    Attributes:
     - tableName
     - row
     - writeOptions
    """


    def __init__(self, tableName=None, row=None, writeOptions=None,):
        self.tableName = tableName
        self.row = row
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.row = TRow()
                    self.row.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putIfPresent_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRUCT, 2)
            self.row.write(oprot)
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 3)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putIfPresent_args)
putIfPresent_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'row', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 3
)


class putIfPresent_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TWriteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putIfPresent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putIfPresent_result)
putIfPresent_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TWriteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class putIfVersion_args(object):
    """
    Attributes:
     - tableName
     - row
     - matchVersion
     - writeOptions
    """


    def __init__(self, tableName=None, row=None, matchVersion=None, writeOptions=None,):
        self.tableName = tableName
        self.row = row
        self.matchVersion = matchVersion
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.row = TRow()
                    self.row.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.matchVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putIfVersion_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRUCT, 2)
            self.row.write(oprot)
            oprot.writeFieldEnd()
        if self.matchVersion is not None:
            oprot.writeFieldBegin('matchVersion', TType.STRING, 3)
            oprot.writeBinary(self.matchVersion)
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 4)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putIfVersion_args)
putIfVersion_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'row', [TRow, None], None, ),  # 2
    (3, TType.STRING, 'matchVersion', 'BINARY', None, ),  # 3
    (4, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 4
)


class putIfVersion_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TWriteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('putIfVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(putIfVersion_result)
putIfVersion_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TWriteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class get_args(object):
    """
    Attributes:
     - tableName
     - key
     - readOptions
    """


    def __init__(self, tableName=None, key=None, readOptions=None,):
        self.tableName = tableName
        self.key = key
        self.readOptions = readOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 3)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_args)
get_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 3
)


class get_result(object):
    """
    Attributes:
     - success
     - ce
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, ce=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.ce = ce
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TGetResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.ce = TConsistencyException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('get_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 1)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(get_result)
get_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TGetResult, None], None, ),  # 0
    (1, TType.STRUCT, 'ce', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class deleteRow_args(object):
    """
    Attributes:
     - tableName
     - key
     - writeOptions
    """


    def __init__(self, tableName=None, key=None, writeOptions=None,):
        self.tableName = tableName
        self.key = key
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteRow_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 3)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteRow_args)
deleteRow_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 3
)


class deleteRow_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TWriteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteRow_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteRow_result)
deleteRow_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TWriteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class deleteRowIfVersion_args(object):
    """
    Attributes:
     - tableName
     - key
     - matchVersion
     - writeOptions
    """


    def __init__(self, tableName=None, key=None, matchVersion=None, writeOptions=None,):
        self.tableName = tableName
        self.key = key
        self.matchVersion = matchVersion
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.matchVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteRowIfVersion_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.matchVersion is not None:
            oprot.writeFieldBegin('matchVersion', TType.STRING, 3)
            oprot.writeBinary(self.matchVersion)
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 4)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteRowIfVersion_args)
deleteRowIfVersion_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRING, 'matchVersion', 'BINARY', None, ),  # 3
    (4, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 4
)


class deleteRowIfVersion_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TWriteResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('deleteRowIfVersion_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(deleteRowIfVersion_result)
deleteRowIfVersion_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TWriteResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class multiDelete_args(object):
    """
    Attributes:
     - tableName
     - key
     - fieldRange
     - includedTable
     - writeOptions
    """


    def __init__(self, tableName=None, key=None, fieldRange=None, includedTable=None, writeOptions=None,):
        self.tableName = tableName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTable = includedTable
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTable = []
                    (_etype40, _size37) = iprot.readListBegin()
                    for _i41 in range(_size37):
                        _elem42 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTable.append(_elem42)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiDelete_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTable is not None:
            oprot.writeFieldBegin('includedTable', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTable))
            for iter43 in self.includedTable:
                oprot.writeString(iter43.encode('utf-8') if sys.version_info[0] == 2 else iter43)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 5)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiDelete_args)
multiDelete_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTable', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 5
)


class multiDelete_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiDelete_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiDelete_result)
multiDelete_result.thrift_spec = (
    (0, TType.I32, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class multiGet_args(object):
    """
    Attributes:
     - tableName
     - key
     - fieldRange
     - includedTables
     - readOptions
    """


    def __init__(self, tableName=None, key=None, fieldRange=None, includedTables=None, readOptions=None,):
        self.tableName = tableName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype47, _size44) = iprot.readListBegin()
                    for _i48 in range(_size44):
                        _elem49 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem49)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiGet_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter50 in self.includedTables:
                oprot.writeString(iter50.encode('utf-8') if sys.version_info[0] == 2 else iter50)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 5)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiGet_args)
multiGet_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 5
)


class multiGet_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMultiGetResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiGet_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiGet_result)
multiGet_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TMultiGetResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class multiGetKeys_args(object):
    """
    Attributes:
     - tableName
     - key
     - fieldRange
     - includedTables
     - readOptions
    """


    def __init__(self, tableName=None, key=None, fieldRange=None, includedTables=None, readOptions=None,):
        self.tableName = tableName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype54, _size51) = iprot.readListBegin()
                    for _i55 in range(_size51):
                        _elem56 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem56)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiGetKeys_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter57 in self.includedTables:
                oprot.writeString(iter57.encode('utf-8') if sys.version_info[0] == 2 else iter57)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 5)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiGetKeys_args)
multiGetKeys_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 5
)


class multiGetKeys_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TMultiGetResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('multiGetKeys_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(multiGetKeys_result)
multiGetKeys_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TMultiGetResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
)


class tableIterator_args(object):
    """
    Attributes:
     - tableName
     - key
     - fieldRange
     - includedTables
     - readOptions
     - direction
     - maxResults
    """


    def __init__(self, tableName=None, key=None, fieldRange=None, includedTables=None, readOptions=None, direction=None, maxResults=None,):
        self.tableName = tableName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions
        self.direction = direction
        self.maxResults = maxResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype61, _size58) = iprot.readListBegin()
                    for _i62 in range(_size58):
                        _elem63 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem63)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.maxResults = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableIterator_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter64 in self.includedTables:
                oprot.writeString(iter64.encode('utf-8') if sys.version_info[0] == 2 else iter64)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 5)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 6)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.maxResults is not None:
            oprot.writeFieldBegin('maxResults', TType.I64, 7)
            oprot.writeI64(self.maxResults)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableIterator_args)
tableIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 5
    (6, TType.I32, 'direction', None, None, ),  # 6
    (7, TType.I64, 'maxResults', None, None, ),  # 7
)


class tableIterator_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - ite
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, ite=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.ite = ite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ite = TIteratorTimeoutException()
                    self.ite.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableIterator_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ite is not None:
            oprot.writeFieldBegin('ite', TType.STRUCT, 6)
            self.ite.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableIterator_result)
tableIterator_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'ite', [TIteratorTimeoutException, None], None, ),  # 6
)


class tableIteratorMulti_args(object):
    """
    Attributes:
     - tableName
     - keys
     - fieldRange
     - includedTables
     - readOptions
     - direction
     - maxResults
     - numParallelIterHint
    """


    def __init__(self, tableName=None, keys=None, fieldRange=None, includedTables=None, readOptions=None, direction=None, maxResults=None, numParallelIterHint=None,):
        self.tableName = tableName
        self.keys = keys
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions
        self.direction = direction
        self.maxResults = maxResults
        self.numParallelIterHint = numParallelIterHint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype68, _size65) = iprot.readListBegin()
                    for _i69 in range(_size65):
                        _elem70 = TRow()
                        _elem70.read(iprot)
                        self.keys.append(_elem70)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype74, _size71) = iprot.readListBegin()
                    for _i75 in range(_size71):
                        _elem76 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem76)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.maxResults = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.numParallelIterHint = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableIteratorMulti_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.keys))
            for iter77 in self.keys:
                iter77.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter78 in self.includedTables:
                oprot.writeString(iter78.encode('utf-8') if sys.version_info[0] == 2 else iter78)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 5)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 6)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.maxResults is not None:
            oprot.writeFieldBegin('maxResults', TType.I64, 7)
            oprot.writeI64(self.maxResults)
            oprot.writeFieldEnd()
        if self.numParallelIterHint is not None:
            oprot.writeFieldBegin('numParallelIterHint', TType.I32, 8)
            oprot.writeI32(self.numParallelIterHint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableIteratorMulti_args)
tableIteratorMulti_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'keys', (TType.STRUCT, [TRow, None], False), None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 5
    (6, TType.I32, 'direction', None, None, ),  # 6
    (7, TType.I64, 'maxResults', None, None, ),  # 7
    (8, TType.I32, 'numParallelIterHint', None, None, ),  # 8
)


class tableIteratorMulti_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - ite
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, ite=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.ite = ite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ite = TIteratorTimeoutException()
                    self.ite.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableIteratorMulti_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ite is not None:
            oprot.writeFieldBegin('ite', TType.STRUCT, 6)
            self.ite.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableIteratorMulti_result)
tableIteratorMulti_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'ite', [TIteratorTimeoutException, None], None, ),  # 6
)


class iteratorNext_args(object):
    """
    Attributes:
     - iteratorId
    """


    def __init__(self, iteratorId=None,):
        self.iteratorId = iteratorId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.iteratorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('iteratorNext_args')
        if self.iteratorId is not None:
            oprot.writeFieldBegin('iteratorId', TType.I64, 1)
            oprot.writeI64(self.iteratorId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(iteratorNext_args)
iteratorNext_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'iteratorId', None, None, ),  # 1
)


class iteratorNext_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - ite
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, ite=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.ite = ite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ite = TIteratorTimeoutException()
                    self.ite.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('iteratorNext_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ite is not None:
            oprot.writeFieldBegin('ite', TType.STRUCT, 6)
            self.ite.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(iteratorNext_result)
iteratorNext_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'ite', [TIteratorTimeoutException, None], None, ),  # 6
)


class iteratorClose_args(object):
    """
    Attributes:
     - iteratorId
    """


    def __init__(self, iteratorId=None,):
        self.iteratorId = iteratorId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.iteratorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('iteratorClose_args')
        if self.iteratorId is not None:
            oprot.writeFieldBegin('iteratorId', TType.I64, 1)
            oprot.writeI64(self.iteratorId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(iteratorClose_args)
iteratorClose_args.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'iteratorId', None, None, ),  # 1
)


class iteratorClose_result(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('iteratorClose_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(iteratorClose_result)
iteratorClose_result.thrift_spec = (
)


class tableKeyIterator_args(object):
    """
    Attributes:
     - tableName
     - key
     - fieldRange
     - includedTables
     - readOptions
     - direction
     - maxResults
    """


    def __init__(self, tableName=None, key=None, fieldRange=None, includedTables=None, readOptions=None, direction=None, maxResults=None,):
        self.tableName = tableName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions
        self.direction = direction
        self.maxResults = maxResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype82, _size79) = iprot.readListBegin()
                    for _i83 in range(_size79):
                        _elem84 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem84)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.maxResults = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableKeyIterator_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 2)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter85 in self.includedTables:
                oprot.writeString(iter85.encode('utf-8') if sys.version_info[0] == 2 else iter85)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 5)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 6)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.maxResults is not None:
            oprot.writeFieldBegin('maxResults', TType.I64, 7)
            oprot.writeI64(self.maxResults)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableKeyIterator_args)
tableKeyIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'key', [TRow, None], None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 5
    (6, TType.I32, 'direction', None, None, ),  # 6
    (7, TType.I64, 'maxResults', None, None, ),  # 7
)


class tableKeyIterator_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - tie
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, tie=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.tie = tie

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.tie = TIteratorTimeoutException()
                    self.tie.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableKeyIterator_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.tie is not None:
            oprot.writeFieldBegin('tie', TType.STRUCT, 6)
            self.tie.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableKeyIterator_result)
tableKeyIterator_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'tie', [TIteratorTimeoutException, None], None, ),  # 6
)


class tableKeyIteratorMulti_args(object):
    """
    Attributes:
     - tableName
     - keys
     - fieldRange
     - includedTables
     - readOptions
     - direction
     - maxResults
     - numParallelIterHint
    """


    def __init__(self, tableName=None, keys=None, fieldRange=None, includedTables=None, readOptions=None, direction=None, maxResults=None, numParallelIterHint=None,):
        self.tableName = tableName
        self.keys = keys
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions
        self.direction = direction
        self.maxResults = maxResults
        self.numParallelIterHint = numParallelIterHint

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.keys = []
                    (_etype89, _size86) = iprot.readListBegin()
                    for _i90 in range(_size86):
                        _elem91 = TRow()
                        _elem91.read(iprot)
                        self.keys.append(_elem91)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype95, _size92) = iprot.readListBegin()
                    for _i96 in range(_size92):
                        _elem97 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem97)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I64:
                    self.maxResults = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.numParallelIterHint = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableKeyIteratorMulti_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.keys is not None:
            oprot.writeFieldBegin('keys', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.keys))
            for iter98 in self.keys:
                iter98.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 3)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter99 in self.includedTables:
                oprot.writeString(iter99.encode('utf-8') if sys.version_info[0] == 2 else iter99)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 5)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 6)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.maxResults is not None:
            oprot.writeFieldBegin('maxResults', TType.I64, 7)
            oprot.writeI64(self.maxResults)
            oprot.writeFieldEnd()
        if self.numParallelIterHint is not None:
            oprot.writeFieldBegin('numParallelIterHint', TType.I32, 8)
            oprot.writeI32(self.numParallelIterHint)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableKeyIteratorMulti_args)
tableKeyIteratorMulti_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'keys', (TType.STRUCT, [TRow, None], False), None, ),  # 2
    (3, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 3
    (4, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 5
    (6, TType.I32, 'direction', None, None, ),  # 6
    (7, TType.I64, 'maxResults', None, None, ),  # 7
    (8, TType.I32, 'numParallelIterHint', None, None, ),  # 8
)


class tableKeyIteratorMulti_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - tie
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, tie=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.tie = tie

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.tie = TIteratorTimeoutException()
                    self.tie.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('tableKeyIteratorMulti_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.tie is not None:
            oprot.writeFieldBegin('tie', TType.STRUCT, 6)
            self.tie.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(tableKeyIteratorMulti_result)
tableKeyIteratorMulti_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'tie', [TIteratorTimeoutException, None], None, ),  # 6
)


class indexIterator_args(object):
    """
    Attributes:
     - tableName
     - indexName
     - key
     - fieldRange
     - includedTables
     - readOptions
     - direction
     - maxResults
    """


    def __init__(self, tableName=None, indexName=None, key=None, fieldRange=None, includedTables=None, readOptions=None, direction=None, maxResults=None,):
        self.tableName = tableName
        self.indexName = indexName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions
        self.direction = direction
        self.maxResults = maxResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.indexName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype103, _size100) = iprot.readListBegin()
                    for _i104 in range(_size100):
                        _elem105 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem105)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.maxResults = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('indexIterator_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.indexName is not None:
            oprot.writeFieldBegin('indexName', TType.STRING, 2)
            oprot.writeString(self.indexName.encode('utf-8') if sys.version_info[0] == 2 else self.indexName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 3)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 4)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter106 in self.includedTables:
                oprot.writeString(iter106.encode('utf-8') if sys.version_info[0] == 2 else iter106)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 6)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 7)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.maxResults is not None:
            oprot.writeFieldBegin('maxResults', TType.I64, 8)
            oprot.writeI64(self.maxResults)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(indexIterator_args)
indexIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'indexName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'key', [TRow, None], None, ),  # 3
    (4, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 4
    (5, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 6
    (7, TType.I32, 'direction', None, None, ),  # 7
    (8, TType.I64, 'maxResults', None, None, ),  # 8
)


class indexIterator_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - ite
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, ite=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.ite = ite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ite = TIteratorTimeoutException()
                    self.ite.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('indexIterator_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ite is not None:
            oprot.writeFieldBegin('ite', TType.STRUCT, 6)
            self.ite.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(indexIterator_result)
indexIterator_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'ite', [TIteratorTimeoutException, None], None, ),  # 6
)


class indexKeyIterator_args(object):
    """
    Attributes:
     - tableName
     - indexName
     - key
     - fieldRange
     - includedTables
     - readOptions
     - direction
     - maxResults
    """


    def __init__(self, tableName=None, indexName=None, key=None, fieldRange=None, includedTables=None, readOptions=None, direction=None, maxResults=None,):
        self.tableName = tableName
        self.indexName = indexName
        self.key = key
        self.fieldRange = fieldRange
        self.includedTables = includedTables
        self.readOptions = readOptions
        self.direction = direction
        self.maxResults = maxResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.indexName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.key = TRow()
                    self.key.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.fieldRange = TFieldRange()
                    self.fieldRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.includedTables = []
                    (_etype110, _size107) = iprot.readListBegin()
                    for _i111 in range(_size107):
                        _elem112 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.includedTables.append(_elem112)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.readOptions = TReadOptions()
                    self.readOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.direction = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I64:
                    self.maxResults = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('indexKeyIterator_args')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.indexName is not None:
            oprot.writeFieldBegin('indexName', TType.STRING, 2)
            oprot.writeString(self.indexName.encode('utf-8') if sys.version_info[0] == 2 else self.indexName)
            oprot.writeFieldEnd()
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRUCT, 3)
            self.key.write(oprot)
            oprot.writeFieldEnd()
        if self.fieldRange is not None:
            oprot.writeFieldBegin('fieldRange', TType.STRUCT, 4)
            self.fieldRange.write(oprot)
            oprot.writeFieldEnd()
        if self.includedTables is not None:
            oprot.writeFieldBegin('includedTables', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.includedTables))
            for iter113 in self.includedTables:
                oprot.writeString(iter113.encode('utf-8') if sys.version_info[0] == 2 else iter113)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.readOptions is not None:
            oprot.writeFieldBegin('readOptions', TType.STRUCT, 6)
            self.readOptions.write(oprot)
            oprot.writeFieldEnd()
        if self.direction is not None:
            oprot.writeFieldBegin('direction', TType.I32, 7)
            oprot.writeI32(self.direction)
            oprot.writeFieldEnd()
        if self.maxResults is not None:
            oprot.writeFieldBegin('maxResults', TType.I64, 8)
            oprot.writeI64(self.maxResults)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(indexKeyIterator_args)
indexKeyIterator_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'indexName', 'UTF8', None, ),  # 2
    (3, TType.STRUCT, 'key', [TRow, None], None, ),  # 3
    (4, TType.STRUCT, 'fieldRange', [TFieldRange, None], None, ),  # 4
    (5, TType.LIST, 'includedTables', (TType.STRING, 'UTF8', False), None, ),  # 5
    (6, TType.STRUCT, 'readOptions', [TReadOptions, None], None, ),  # 6
    (7, TType.I32, 'direction', None, None, ),  # 7
    (8, TType.I64, 'maxResults', None, None, ),  # 8
)


class indexKeyIterator_result(object):
    """
    Attributes:
     - success
     - de
     - re
     - fe
     - pe
     - iae
     - ite
    """


    def __init__(self, success=None, de=None, re=None, fe=None, pe=None, iae=None, ite=None,):
        self.success = success
        self.de = de
        self.re = re
        self.fe = fe
        self.pe = pe
        self.iae = iae
        self.ite = ite

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TIteratorResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TConsistencyException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.re = TRequestTimeoutException()
                    self.re.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.ite = TIteratorTimeoutException()
                    self.ite.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('indexKeyIterator_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.re is not None:
            oprot.writeFieldBegin('re', TType.STRUCT, 2)
            self.re.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 4)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 5)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ite is not None:
            oprot.writeFieldBegin('ite', TType.STRUCT, 6)
            self.ite.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(indexKeyIterator_result)
indexKeyIterator_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TIteratorResult, None], None, ),  # 0
    (1, TType.STRUCT, 'de', [TConsistencyException, None], None, ),  # 1
    (2, TType.STRUCT, 're', [TRequestTimeoutException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 4
    (5, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 5
    (6, TType.STRUCT, 'ite', [TIteratorTimeoutException, None], None, ),  # 6
)


class refreshTables_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('refreshTables_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(refreshTables_args)
refreshTables_args.thrift_spec = (
)


class refreshTables_result(object):
    """
    Attributes:
     - fe
    """


    def __init__(self, fe=None,):
        self.fe = fe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('refreshTables_result')
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(refreshTables_result)
refreshTables_result.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
)


class executeSync_args(object):
    """
    Attributes:
     - statement
    """


    def __init__(self, statement=None,):
        self.statement = statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeSync_args')
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 1)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeSync_args)
executeSync_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'statement', 'UTF8', None, ),  # 1
)


class executeSync_result(object):
    """
    Attributes:
     - success
     - fe
     - ise
     - pe
    """


    def __init__(self, success=None, fe=None, ise=None, pe=None,):
        self.success = success
        self.fe = fe
        self.ise = ise
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ise = TIllegalArgumentException()
                    self.ise.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeSync_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.ise is not None:
            oprot.writeFieldBegin('ise', TType.STRUCT, 2)
            self.ise.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeSync_result)
executeSync_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'ise', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class execute_args(object):
    """
    Attributes:
     - statement
    """


    def __init__(self, statement=None,):
        self.statement = statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_args')
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 1)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_args)
execute_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'statement', 'UTF8', None, ),  # 1
)


class execute_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('execute_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(execute_result)
execute_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executionFutureCancel_args(object):
    """
    Attributes:
     - planId
     - mayInterruptIfRunning
    """


    def __init__(self, planId=None, mayInterruptIfRunning=None,):
        self.planId = planId
        self.mayInterruptIfRunning = mayInterruptIfRunning

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.planId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.mayInterruptIfRunning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureCancel_args')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.I32, 1)
            oprot.writeI32(self.planId)
            oprot.writeFieldEnd()
        if self.mayInterruptIfRunning is not None:
            oprot.writeFieldBegin('mayInterruptIfRunning', TType.BOOL, 2)
            oprot.writeBool(self.mayInterruptIfRunning)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureCancel_args)
executionFutureCancel_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'planId', None, None, ),  # 1
    (2, TType.BOOL, 'mayInterruptIfRunning', None, None, ),  # 2
)


class executionFutureCancel_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureCancel_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureCancel_result)
executionFutureCancel_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executionFutureGet_args(object):
    """
    Attributes:
     - planId
    """


    def __init__(self, planId=None,):
        self.planId = planId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.planId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGet_args')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.I32, 1)
            oprot.writeI32(self.planId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGet_args)
executionFutureGet_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'planId', None, None, ),  # 1
)


class executionFutureGet_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - ce
     - ee
     - ie
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, ce=None, ee=None, ie=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.ce = ce
        self.ee = ee
        self.ie = ie
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = TCancellationException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ee = TExecutionException()
                    self.ee.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ie = TInterruptedException()
                    self.ie.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGet_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        if self.ee is not None:
            oprot.writeFieldBegin('ee', TType.STRUCT, 4)
            self.ee.write(oprot)
            oprot.writeFieldEnd()
        if self.ie is not None:
            oprot.writeFieldBegin('ie', TType.STRUCT, 5)
            self.ie.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 6)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGet_result)
executionFutureGet_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [TCancellationException, None], None, ),  # 3
    (4, TType.STRUCT, 'ee', [TExecutionException, None], None, ),  # 4
    (5, TType.STRUCT, 'ie', [TInterruptedException, None], None, ),  # 5
    (6, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 6
)


class executionFutureGetTimeout_args(object):
    """
    Attributes:
     - planId
     - timeoutMs
    """


    def __init__(self, planId=None, timeoutMs=None,):
        self.planId = planId
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.planId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGetTimeout_args')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.I32, 1)
            oprot.writeI32(self.planId)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGetTimeout_args)
executionFutureGetTimeout_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'planId', None, None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
)


class executionFutureGetTimeout_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - ie
     - te
     - ee
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, ie=None, te=None, ee=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.ie = ie
        self.te = te
        self.ee = ee
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ie = TInterruptedException()
                    self.ie.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.te = TTimeoutException()
                    self.te.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ee = TExecutionException()
                    self.ee.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGetTimeout_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ie is not None:
            oprot.writeFieldBegin('ie', TType.STRUCT, 3)
            self.ie.write(oprot)
            oprot.writeFieldEnd()
        if self.te is not None:
            oprot.writeFieldBegin('te', TType.STRUCT, 4)
            self.te.write(oprot)
            oprot.writeFieldEnd()
        if self.ee is not None:
            oprot.writeFieldBegin('ee', TType.STRUCT, 5)
            self.ee.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 6)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGetTimeout_result)
executionFutureGetTimeout_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'ie', [TInterruptedException, None], None, ),  # 3
    (4, TType.STRUCT, 'te', [TTimeoutException, None], None, ),  # 4
    (5, TType.STRUCT, 'ee', [TExecutionException, None], None, ),  # 5
    (6, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 6
)


class executionFutureUpdateStatus_args(object):
    """
    Attributes:
     - planId
    """


    def __init__(self, planId=None,):
        self.planId = planId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.planId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureUpdateStatus_args')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.I32, 1)
            oprot.writeI32(self.planId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureUpdateStatus_args)
executionFutureUpdateStatus_args.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'planId', None, None, ),  # 1
)


class executionFutureUpdateStatus_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureUpdateStatus_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureUpdateStatus_result)
executionFutureUpdateStatus_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResult, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executeSyncV2_args(object):
    """
    Attributes:
     - statement
    """


    def __init__(self, statement=None,):
        self.statement = statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeSyncV2_args')
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 1)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeSyncV2_args)
executeSyncV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'statement', 'UTF8', None, ),  # 1
)


class executeSyncV2_result(object):
    """
    Attributes:
     - success
     - fe
     - ise
     - pe
    """


    def __init__(self, success=None, fe=None, ise=None, pe=None,):
        self.success = success
        self.fe = fe
        self.ise = ise
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResultV2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ise = TIllegalArgumentException()
                    self.ise.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeSyncV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.ise is not None:
            oprot.writeFieldBegin('ise', TType.STRUCT, 2)
            self.ise.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeSyncV2_result)
executeSyncV2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResultV2, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'ise', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executeV2_args(object):
    """
    Attributes:
     - statement
    """


    def __init__(self, statement=None,):
        self.statement = statement

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeV2_args')
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 1)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeV2_args)
executeV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'statement', 'UTF8', None, ),  # 1
)


class executeV2_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResultV2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeV2_result)
executeV2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResultV2, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executionFutureCancelV2_args(object):
    """
    Attributes:
     - executionId
     - mayInterruptIfRunning
    """


    def __init__(self, executionId=None, mayInterruptIfRunning=None,):
        self.executionId = executionId
        self.mayInterruptIfRunning = mayInterruptIfRunning

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.executionId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.mayInterruptIfRunning = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureCancelV2_args')
        if self.executionId is not None:
            oprot.writeFieldBegin('executionId', TType.STRING, 1)
            oprot.writeBinary(self.executionId)
            oprot.writeFieldEnd()
        if self.mayInterruptIfRunning is not None:
            oprot.writeFieldBegin('mayInterruptIfRunning', TType.BOOL, 2)
            oprot.writeBool(self.mayInterruptIfRunning)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureCancelV2_args)
executionFutureCancelV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'executionId', 'BINARY', None, ),  # 1
    (2, TType.BOOL, 'mayInterruptIfRunning', None, None, ),  # 2
)


class executionFutureCancelV2_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureCancelV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureCancelV2_result)
executionFutureCancelV2_result.thrift_spec = (
    (0, TType.BOOL, 'success', None, None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executionFutureGetV2_args(object):
    """
    Attributes:
     - executionId
    """


    def __init__(self, executionId=None,):
        self.executionId = executionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.executionId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGetV2_args')
        if self.executionId is not None:
            oprot.writeFieldBegin('executionId', TType.STRING, 1)
            oprot.writeBinary(self.executionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGetV2_args)
executionFutureGetV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'executionId', 'BINARY', None, ),  # 1
)


class executionFutureGetV2_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - ce
     - ee
     - ie
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, ce=None, ee=None, ie=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.ce = ce
        self.ee = ee
        self.ie = ie
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResultV2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ce = TCancellationException()
                    self.ce.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.ee = TExecutionException()
                    self.ee.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ie = TInterruptedException()
                    self.ie.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGetV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ce is not None:
            oprot.writeFieldBegin('ce', TType.STRUCT, 3)
            self.ce.write(oprot)
            oprot.writeFieldEnd()
        if self.ee is not None:
            oprot.writeFieldBegin('ee', TType.STRUCT, 4)
            self.ee.write(oprot)
            oprot.writeFieldEnd()
        if self.ie is not None:
            oprot.writeFieldBegin('ie', TType.STRUCT, 5)
            self.ie.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 6)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGetV2_result)
executionFutureGetV2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResultV2, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'ce', [TCancellationException, None], None, ),  # 3
    (4, TType.STRUCT, 'ee', [TExecutionException, None], None, ),  # 4
    (5, TType.STRUCT, 'ie', [TInterruptedException, None], None, ),  # 5
    (6, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 6
)


class executionFutureGetTimeoutV2_args(object):
    """
    Attributes:
     - executionId
     - timeoutMs
    """


    def __init__(self, executionId=None, timeoutMs=None,):
        self.executionId = executionId
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.executionId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGetTimeoutV2_args')
        if self.executionId is not None:
            oprot.writeFieldBegin('executionId', TType.STRING, 1)
            oprot.writeBinary(self.executionId)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGetTimeoutV2_args)
executionFutureGetTimeoutV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'executionId', 'BINARY', None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
)


class executionFutureGetTimeoutV2_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - ie
     - te
     - ee
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, ie=None, te=None, ee=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.ie = ie
        self.te = te
        self.ee = ee
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResultV2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.ie = TInterruptedException()
                    self.ie.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.te = TTimeoutException()
                    self.te.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.ee = TExecutionException()
                    self.ee.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureGetTimeoutV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.ie is not None:
            oprot.writeFieldBegin('ie', TType.STRUCT, 3)
            self.ie.write(oprot)
            oprot.writeFieldEnd()
        if self.te is not None:
            oprot.writeFieldBegin('te', TType.STRUCT, 4)
            self.te.write(oprot)
            oprot.writeFieldEnd()
        if self.ee is not None:
            oprot.writeFieldBegin('ee', TType.STRUCT, 5)
            self.ee.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 6)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureGetTimeoutV2_result)
executionFutureGetTimeoutV2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResultV2, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'ie', [TInterruptedException, None], None, ),  # 3
    (4, TType.STRUCT, 'te', [TTimeoutException, None], None, ),  # 4
    (5, TType.STRUCT, 'ee', [TExecutionException, None], None, ),  # 5
    (6, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 6
)


class executionFutureUpdateStatusV2_args(object):
    """
    Attributes:
     - executionId
    """


    def __init__(self, executionId=None,):
        self.executionId = executionId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.executionId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureUpdateStatusV2_args')
        if self.executionId is not None:
            oprot.writeFieldBegin('executionId', TType.STRING, 1)
            oprot.writeBinary(self.executionId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureUpdateStatusV2_args)
executionFutureUpdateStatusV2_args.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'executionId', 'BINARY', None, ),  # 1
)


class executionFutureUpdateStatusV2_result(object):
    """
    Attributes:
     - success
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TStatementResultV2()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executionFutureUpdateStatusV2_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 1)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 2)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 3)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executionFutureUpdateStatusV2_result)
executionFutureUpdateStatusV2_result.thrift_spec = (
    (0, TType.STRUCT, 'success', [TStatementResultV2, None], None, ),  # 0
    (1, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 1
    (2, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 2
    (3, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 3
)


class executeUpdates_args(object):
    """
    Attributes:
     - operations
     - writeOptions
    """


    def __init__(self, operations=None, writeOptions=None,):
        self.operations = operations
        self.writeOptions = writeOptions

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.operations = []
                    (_etype117, _size114) = iprot.readListBegin()
                    for _i118 in range(_size114):
                        _elem119 = TOperation()
                        _elem119.read(iprot)
                        self.operations.append(_elem119)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.writeOptions = TWriteOptions()
                    self.writeOptions.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeUpdates_args')
        if self.operations is not None:
            oprot.writeFieldBegin('operations', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.operations))
            for iter120 in self.operations:
                iter120.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.writeOptions is not None:
            oprot.writeFieldBegin('writeOptions', TType.STRUCT, 2)
            self.writeOptions.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeUpdates_args)
executeUpdates_args.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'operations', (TType.STRUCT, [TOperation, None], False), None, ),  # 1
    (2, TType.STRUCT, 'writeOptions', [TWriteOptions, None], None, ),  # 2
)


class executeUpdates_result(object):
    """
    Attributes:
     - success
     - de
     - toee
     - fe
     - iae
     - pe
    """


    def __init__(self, success=None, de=None, toee=None, fe=None, iae=None, pe=None,):
        self.success = success
        self.de = de
        self.toee = toee
        self.fe = fe
        self.iae = iae
        self.pe = pe

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype124, _size121) = iprot.readListBegin()
                    for _i125 in range(_size121):
                        _elem126 = TWriteResult()
                        _elem126.read(iprot)
                        self.success.append(_elem126)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.de = TDurabilityException()
                    self.de.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.toee = TTableOpExecutionException()
                    self.toee.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.fe = TFaultException()
                    self.fe.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.iae = TIllegalArgumentException()
                    self.iae.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.pe = TProxyException()
                    self.pe.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('executeUpdates_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter127 in self.success:
                iter127.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.de is not None:
            oprot.writeFieldBegin('de', TType.STRUCT, 1)
            self.de.write(oprot)
            oprot.writeFieldEnd()
        if self.toee is not None:
            oprot.writeFieldBegin('toee', TType.STRUCT, 2)
            self.toee.write(oprot)
            oprot.writeFieldEnd()
        if self.fe is not None:
            oprot.writeFieldBegin('fe', TType.STRUCT, 3)
            self.fe.write(oprot)
            oprot.writeFieldEnd()
        if self.iae is not None:
            oprot.writeFieldBegin('iae', TType.STRUCT, 4)
            self.iae.write(oprot)
            oprot.writeFieldEnd()
        if self.pe is not None:
            oprot.writeFieldBegin('pe', TType.STRUCT, 5)
            self.pe.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(executeUpdates_result)
executeUpdates_result.thrift_spec = (
    (0, TType.LIST, 'success', (TType.STRUCT, [TWriteResult, None], False), None, ),  # 0
    (1, TType.STRUCT, 'de', [TDurabilityException, None], None, ),  # 1
    (2, TType.STRUCT, 'toee', [TTableOpExecutionException, None], None, ),  # 2
    (3, TType.STRUCT, 'fe', [TFaultException, None], None, ),  # 3
    (4, TType.STRUCT, 'iae', [TIllegalArgumentException, None], None, ),  # 4
    (5, TType.STRUCT, 'pe', [TProxyException, None], None, ),  # 5
)


class getOptions_args(object):


    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getOptions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getOptions_args)
getOptions_args.thrift_spec = (
)


class getOptions_result(object):
    """
    Attributes:
     - success
    """


    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype129, _vtype130, _size128) = iprot.readMapBegin()
                    for _i132 in range(_size128):
                        _key133 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val134 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key133] = _val134
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('getOptions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter135, viter136 in self.success.items():
                oprot.writeString(kiter135.encode('utf-8') if sys.version_info[0] == 2 else kiter135)
                oprot.writeString(viter136.encode('utf-8') if sys.version_info[0] == 2 else viter136)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(getOptions_result)
getOptions_result.thrift_spec = (
    (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
)
fix_spec(all_structs)
del all_structs

