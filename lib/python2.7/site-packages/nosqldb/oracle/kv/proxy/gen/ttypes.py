#
# Autogenerated by Thrift Compiler (0.11.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class TModuleInfo(object):
    PROXY_SERVER = 2
    JAVA_CLIENT = 3

    _VALUES_TO_NAMES = {
        2: "PROXY_SERVER",
        3: "JAVA_CLIENT",
    }

    _NAMES_TO_VALUES = {
        "PROXY_SERVER": 2,
        "JAVA_CLIENT": 3,
    }


class TVerifyError(object):
    INVALID_KVSTORE_Name = 1
    INVALID_KVSTORE_HelperHosts = 2
    Unsupported_Driver_ProtocolVersion = 3

    _VALUES_TO_NAMES = {
        1: "INVALID_KVSTORE_Name",
        2: "INVALID_KVSTORE_HelperHosts",
        3: "Unsupported_Driver_ProtocolVersion",
    }

    _NAMES_TO_VALUES = {
        "INVALID_KVSTORE_Name": 1,
        "INVALID_KVSTORE_HelperHosts": 2,
        "Unsupported_Driver_ProtocolVersion": 3,
    }


class TSyncPolicy(object):
    NO_SYNC = 1
    SYNC = 2
    WRITE_NO_SYNC = 3

    _VALUES_TO_NAMES = {
        1: "NO_SYNC",
        2: "SYNC",
        3: "WRITE_NO_SYNC",
    }

    _NAMES_TO_VALUES = {
        "NO_SYNC": 1,
        "SYNC": 2,
        "WRITE_NO_SYNC": 3,
    }


class TReplicaAckPolicy(object):
    ALL = 1
    NONE = 2
    SIMPLE_MAJORITY = 3

    _VALUES_TO_NAMES = {
        1: "ALL",
        2: "NONE",
        3: "SIMPLE_MAJORITY",
    }

    _NAMES_TO_VALUES = {
        "ALL": 1,
        "NONE": 2,
        "SIMPLE_MAJORITY": 3,
    }


class TReturnChoice(object):
    """
    Specifies whether to return the row value, version, both or neither.
    For best performance, it is important to choose only the properties that
    are required. The store is optimized to avoid I/O when the requested
    properties are in cache.

    """
    ALL = 1
    NONE = 2
    ONLY_VALUE = 3
    ONLY_VERSION = 4

    _VALUES_TO_NAMES = {
        1: "ALL",
        2: "NONE",
        3: "ONLY_VALUE",
        4: "ONLY_VERSION",
    }

    _NAMES_TO_VALUES = {
        "ALL": 1,
        "NONE": 2,
        "ONLY_VALUE": 3,
        "ONLY_VERSION": 4,
    }


class TSimpleConsistency(object):
    ABSOLUTE = 1
    NONE_REQUIRED = 2
    NONE_REQUIRED_NO_MASTER = 3

    _VALUES_TO_NAMES = {
        1: "ABSOLUTE",
        2: "NONE_REQUIRED",
        3: "NONE_REQUIRED_NO_MASTER",
    }

    _NAMES_TO_VALUES = {
        "ABSOLUTE": 1,
        "NONE_REQUIRED": 2,
        "NONE_REQUIRED_NO_MASTER": 3,
    }


class TTimeUnit(object):
    HOURS = 1
    DAYS = 2

    _VALUES_TO_NAMES = {
        1: "HOURS",
        2: "DAYS",
    }

    _NAMES_TO_VALUES = {
        "HOURS": 1,
        "DAYS": 2,
    }


class TDirection(object):
    FORWARD = 1
    REVERSE = 2
    UNORDERED = 3

    _VALUES_TO_NAMES = {
        1: "FORWARD",
        2: "REVERSE",
        3: "UNORDERED",
    }

    _NAMES_TO_VALUES = {
        "FORWARD": 1,
        "REVERSE": 2,
        "UNORDERED": 3,
    }


class TOperationType(object):
    """
    The types of TOperation

    """
    DELETE = 1
    DELETE_IF_VERSION = 2
    PUT = 3
    PUT_IF_ABSENT = 4
    PUT_IF_PRESENT = 5
    PUT_IF_VERSION = 6

    _VALUES_TO_NAMES = {
        1: "DELETE",
        2: "DELETE_IF_VERSION",
        3: "PUT",
        4: "PUT_IF_ABSENT",
        5: "PUT_IF_PRESENT",
        6: "PUT_IF_VERSION",
    }

    _NAMES_TO_VALUES = {
        "DELETE": 1,
        "DELETE_IF_VERSION": 2,
        "PUT": 3,
        "PUT_IF_ABSENT": 4,
        "PUT_IF_PRESENT": 5,
        "PUT_IF_VERSION": 6,
    }


class TVerifyProperties(object):
    """
    Attributes:
     - kvStoreName: Must match the store name of the Proxy Server

     - kvStoreHelperHosts: List must have at least one entry and all entries
    must be contained in the list that the server was started with.
     - username: The security username, required for secured stores.

     - readZones: The zones in which nodes must be located to be used for read operations.

     - driverProtocolVersion: The protocol version that the driver uses. This is a required field,
    for all drivers v2+.

    """


    def __init__(self, kvStoreName=None, kvStoreHelperHosts=None, username=None, readZones=None, driverProtocolVersion=None,):
        self.kvStoreName = kvStoreName
        self.kvStoreHelperHosts = kvStoreHelperHosts
        self.username = username
        self.readZones = readZones
        self.driverProtocolVersion = driverProtocolVersion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.kvStoreName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.kvStoreHelperHosts = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.kvStoreHelperHosts.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.username = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.LIST:
                    self.readZones = []
                    (_etype9, _size6) = iprot.readListBegin()
                    for _i10 in range(_size6):
                        _elem11 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.readZones.append(_elem11)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.driverProtocolVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TVerifyProperties')
        if self.kvStoreName is not None:
            oprot.writeFieldBegin('kvStoreName', TType.STRING, 1)
            oprot.writeString(self.kvStoreName.encode('utf-8') if sys.version_info[0] == 2 else self.kvStoreName)
            oprot.writeFieldEnd()
        if self.kvStoreHelperHosts is not None:
            oprot.writeFieldBegin('kvStoreHelperHosts', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.kvStoreHelperHosts))
            for iter12 in self.kvStoreHelperHosts:
                oprot.writeString(iter12.encode('utf-8') if sys.version_info[0] == 2 else iter12)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.username is not None:
            oprot.writeFieldBegin('username', TType.STRING, 3)
            oprot.writeString(self.username.encode('utf-8') if sys.version_info[0] == 2 else self.username)
            oprot.writeFieldEnd()
        if self.readZones is not None:
            oprot.writeFieldBegin('readZones', TType.LIST, 4)
            oprot.writeListBegin(TType.STRING, len(self.readZones))
            for iter13 in self.readZones:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.driverProtocolVersion is not None:
            oprot.writeFieldBegin('driverProtocolVersion', TType.I32, 5)
            oprot.writeI32(self.driverProtocolVersion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TVerifyResult(object):
    """
    Attributes:
     - isConnected
     - errorType
     - message
     - proxyProtocolVersion
    """


    def __init__(self, isConnected=None, errorType=None, message=None, proxyProtocolVersion=4,):
        self.isConnected = isConnected
        self.errorType = errorType
        self.message = message
        if proxyProtocolVersion is self.thrift_spec[4][4]:
            proxyProtocolVersion = 4
        self.proxyProtocolVersion = proxyProtocolVersion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.BOOL:
                    self.isConnected = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.errorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.proxyProtocolVersion = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TVerifyResult')
        if self.isConnected is not None:
            oprot.writeFieldBegin('isConnected', TType.BOOL, 1)
            oprot.writeBool(self.isConnected)
            oprot.writeFieldEnd()
        if self.errorType is not None:
            oprot.writeFieldBegin('errorType', TType.I32, 2)
            oprot.writeI32(self.errorType)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 3)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.proxyProtocolVersion is not None:
            oprot.writeFieldBegin('proxyProtocolVersion', TType.I32, 4)
            oprot.writeI32(self.proxyProtocolVersion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDurability(object):
    """
    Attributes:
     - masterSync
     - replicaAck
     - replicaSync
    """


    def __init__(self, masterSync=None, replicaAck=None, replicaSync=None,):
        self.masterSync = masterSync
        self.replicaAck = replicaAck
        self.replicaSync = replicaSync

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.masterSync = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.replicaAck = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.replicaSync = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDurability')
        if self.masterSync is not None:
            oprot.writeFieldBegin('masterSync', TType.I32, 1)
            oprot.writeI32(self.masterSync)
            oprot.writeFieldEnd()
        if self.replicaAck is not None:
            oprot.writeFieldBegin('replicaAck', TType.I32, 2)
            oprot.writeI32(self.replicaAck)
            oprot.writeFieldEnd()
        if self.replicaSync is not None:
            oprot.writeFieldBegin('replicaSync', TType.I32, 3)
            oprot.writeI32(self.replicaSync)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TWriteOptions(object):
    """
    Attributes:
     - durability
     - timeoutMs
     - returnChoice
     - updateTTL
    """


    def __init__(self, durability=None, timeoutMs=None, returnChoice=None, updateTTL=False,):
        self.durability = durability
        self.timeoutMs = timeoutMs
        self.returnChoice = returnChoice
        self.updateTTL = updateTTL

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.durability = TDurability()
                    self.durability.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.returnChoice = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.updateTTL = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TWriteOptions')
        if self.durability is not None:
            oprot.writeFieldBegin('durability', TType.STRUCT, 1)
            self.durability.write(oprot)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        if self.returnChoice is not None:
            oprot.writeFieldBegin('returnChoice', TType.I32, 3)
            oprot.writeI32(self.returnChoice)
            oprot.writeFieldEnd()
        if self.updateTTL is not None:
            oprot.writeFieldBegin('updateTTL', TType.BOOL, 4)
            oprot.writeBool(self.updateTTL)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimeConsistency(object):
    """
    Attributes:
     - permissibleLag
     - timeoutMs
    """


    def __init__(self, permissibleLag=None, timeoutMs=None,):
        self.permissibleLag = permissibleLag
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.permissibleLag = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeConsistency')
        if self.permissibleLag is not None:
            oprot.writeFieldBegin('permissibleLag', TType.I64, 1)
            oprot.writeI64(self.permissibleLag)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TVersionConsistency(object):
    """
    Attributes:
     - version
     - timeoutMs
    """


    def __init__(self, version=None, timeoutMs=None,):
        self.version = version
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.version = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TVersionConsistency')
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRING, 1)
            oprot.writeBinary(self.version)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConsistency(object):
    """
    Attributes:
     - simple
     - time
     - version
    """


    def __init__(self, simple=None, time=None, version=None,):
        self.simple = simple
        self.time = time
        self.version = version

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.simple = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.time = TTimeConsistency()
                    self.time.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.version = TVersionConsistency()
                    self.version.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConsistency')
        if self.simple is not None:
            oprot.writeFieldBegin('simple', TType.I32, 1)
            oprot.writeI32(self.simple)
            oprot.writeFieldEnd()
        if self.time is not None:
            oprot.writeFieldBegin('time', TType.STRUCT, 2)
            self.time.write(oprot)
            oprot.writeFieldEnd()
        if self.version is not None:
            oprot.writeFieldBegin('version', TType.STRUCT, 3)
            self.version.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TReadOptions(object):
    """
    Attributes:
     - consistency
     - timeoutMs
    """


    def __init__(self, consistency=None, timeoutMs=None,):
        self.consistency = consistency
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.consistency = TConsistency()
                    self.consistency.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TReadOptions')
        if self.consistency is not None:
            oprot.writeFieldBegin('consistency', TType.STRUCT, 1)
            self.consistency.write(oprot)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimeToLive(object):
    """
    Attributes:
     - value
     - timeUnit
    """


    def __init__(self, value=None, timeUnit=None,):
        self.value = value
        self.timeUnit = timeUnit

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.value = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.timeUnit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeToLive')
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.I64, 1)
            oprot.writeI64(self.value)
            oprot.writeFieldEnd()
        if self.timeUnit is not None:
            oprot.writeFieldBegin('timeUnit', TType.I32, 2)
            oprot.writeI32(self.timeUnit)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRow(object):
    """
    Attributes:
     - jsonRow
     - ttl
    """


    def __init__(self, jsonRow=None, ttl=None,):
        self.jsonRow = jsonRow
        self.ttl = ttl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jsonRow = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.ttl = TTimeToLive()
                    self.ttl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRow')
        if self.jsonRow is not None:
            oprot.writeFieldBegin('jsonRow', TType.STRING, 1)
            oprot.writeString(self.jsonRow.encode('utf-8') if sys.version_info[0] == 2 else self.jsonRow)
            oprot.writeFieldEnd()
        if self.ttl is not None:
            oprot.writeFieldBegin('ttl', TType.STRUCT, 2)
            self.ttl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TWriteResult(object):
    """
    Attributes:
     - currentRowVersion
     - previousRow
     - previousRowVersion
     - wasDeleted
     - expiration
    """


    def __init__(self, currentRowVersion=None, previousRow=None, previousRowVersion=None, wasDeleted=None, expiration=0,):
        self.currentRowVersion = currentRowVersion
        self.previousRow = previousRow
        self.previousRowVersion = previousRowVersion
        self.wasDeleted = wasDeleted
        if expiration is self.thrift_spec[5][4]:
            expiration = 0
        self.expiration = expiration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.currentRowVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.previousRow = TRow()
                    self.previousRow.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.previousRowVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.wasDeleted = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I64:
                    self.expiration = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TWriteResult')
        if self.currentRowVersion is not None:
            oprot.writeFieldBegin('currentRowVersion', TType.STRING, 1)
            oprot.writeBinary(self.currentRowVersion)
            oprot.writeFieldEnd()
        if self.previousRow is not None:
            oprot.writeFieldBegin('previousRow', TType.STRUCT, 2)
            self.previousRow.write(oprot)
            oprot.writeFieldEnd()
        if self.previousRowVersion is not None:
            oprot.writeFieldBegin('previousRowVersion', TType.STRING, 3)
            oprot.writeBinary(self.previousRowVersion)
            oprot.writeFieldEnd()
        if self.wasDeleted is not None:
            oprot.writeFieldBegin('wasDeleted', TType.BOOL, 4)
            oprot.writeBool(self.wasDeleted)
            oprot.writeFieldEnd()
        if self.expiration is not None:
            oprot.writeFieldBegin('expiration', TType.I64, 5)
            oprot.writeI64(self.expiration)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGetResult(object):
    """
    Attributes:
     - currentRow
     - currentRowVersion
     - expiration
    """


    def __init__(self, currentRow=None, currentRowVersion=None, expiration=0,):
        self.currentRow = currentRow
        self.currentRowVersion = currentRowVersion
        if expiration is self.thrift_spec[3][4]:
            expiration = 0
        self.expiration = expiration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.currentRow = TRow()
                    self.currentRow.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.currentRowVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.expiration = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGetResult')
        if self.currentRow is not None:
            oprot.writeFieldBegin('currentRow', TType.STRUCT, 1)
            self.currentRow.write(oprot)
            oprot.writeFieldEnd()
        if self.currentRowVersion is not None:
            oprot.writeFieldBegin('currentRowVersion', TType.STRING, 2)
            oprot.writeBinary(self.currentRowVersion)
            oprot.writeFieldEnd()
        if self.expiration is not None:
            oprot.writeFieldBegin('expiration', TType.I64, 3)
            oprot.writeI64(self.expiration)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFieldRange(object):
    """
    Attributes:
     - fieldName
     - startValue
     - startIsInclusive
     - endValue
     - endIsInclusive
    """


    def __init__(self, fieldName=None, startValue=None, startIsInclusive=None, endValue=None, endIsInclusive=None,):
        self.fieldName = fieldName
        self.startValue = startValue
        self.startIsInclusive = startIsInclusive
        self.endValue = endValue
        self.endIsInclusive = endIsInclusive

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.fieldName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.startValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.startIsInclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.endIsInclusive = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFieldRange')
        if self.fieldName is not None:
            oprot.writeFieldBegin('fieldName', TType.STRING, 1)
            oprot.writeString(self.fieldName.encode('utf-8') if sys.version_info[0] == 2 else self.fieldName)
            oprot.writeFieldEnd()
        if self.startValue is not None:
            oprot.writeFieldBegin('startValue', TType.STRING, 2)
            oprot.writeString(self.startValue.encode('utf-8') if sys.version_info[0] == 2 else self.startValue)
            oprot.writeFieldEnd()
        if self.startIsInclusive is not None:
            oprot.writeFieldBegin('startIsInclusive', TType.BOOL, 3)
            oprot.writeBool(self.startIsInclusive)
            oprot.writeFieldEnd()
        if self.endValue is not None:
            oprot.writeFieldBegin('endValue', TType.STRING, 4)
            oprot.writeString(self.endValue.encode('utf-8') if sys.version_info[0] == 2 else self.endValue)
            oprot.writeFieldEnd()
        if self.endIsInclusive is not None:
            oprot.writeFieldBegin('endIsInclusive', TType.BOOL, 5)
            oprot.writeBool(self.endIsInclusive)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRowAndMetadata(object):
    """
    Attributes:
     - jsonRow
     - rowVersion
     - tableId
     - expiration
    """


    def __init__(self, jsonRow=None, rowVersion=None, tableId=None, expiration=0,):
        self.jsonRow = jsonRow
        self.rowVersion = rowVersion
        self.tableId = tableId
        if expiration is self.thrift_spec[4][4]:
            expiration = 0
        self.expiration = expiration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.jsonRow = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.rowVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.tableId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.expiration = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRowAndMetadata')
        if self.jsonRow is not None:
            oprot.writeFieldBegin('jsonRow', TType.STRING, 1)
            oprot.writeString(self.jsonRow.encode('utf-8') if sys.version_info[0] == 2 else self.jsonRow)
            oprot.writeFieldEnd()
        if self.rowVersion is not None:
            oprot.writeFieldBegin('rowVersion', TType.STRING, 2)
            oprot.writeBinary(self.rowVersion)
            oprot.writeFieldEnd()
        if self.tableId is not None:
            oprot.writeFieldBegin('tableId', TType.I32, 3)
            oprot.writeI32(self.tableId)
            oprot.writeFieldEnd()
        if self.expiration is not None:
            oprot.writeFieldBegin('expiration', TType.I64, 4)
            oprot.writeI64(self.expiration)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMultiGetResult(object):
    """
    Attributes:
     - idToTableNames
     - rowsWithMetadata
    """


    def __init__(self, idToTableNames=None, rowsWithMetadata=None,):
        self.idToTableNames = idToTableNames
        self.rowsWithMetadata = rowsWithMetadata

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.idToTableNames = {}
                    (_ktype15, _vtype16, _size14) = iprot.readMapBegin()
                    for _i18 in range(_size14):
                        _key19 = iprot.readI32()
                        _val20 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.idToTableNames[_key19] = _val20
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.rowsWithMetadata = []
                    (_etype24, _size21) = iprot.readListBegin()
                    for _i25 in range(_size21):
                        _elem26 = TRowAndMetadata()
                        _elem26.read(iprot)
                        self.rowsWithMetadata.append(_elem26)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMultiGetResult')
        if self.idToTableNames is not None:
            oprot.writeFieldBegin('idToTableNames', TType.MAP, 1)
            oprot.writeMapBegin(TType.I32, TType.STRING, len(self.idToTableNames))
            for kiter27, viter28 in self.idToTableNames.items():
                oprot.writeI32(kiter27)
                oprot.writeString(viter28.encode('utf-8') if sys.version_info[0] == 2 else viter28)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.rowsWithMetadata is not None:
            oprot.writeFieldBegin('rowsWithMetadata', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.rowsWithMetadata))
            for iter29 in self.rowsWithMetadata:
                iter29.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIteratorResult(object):
    """
    Attributes:
     - iteratorId
     - result
     - hasMore
    """


    def __init__(self, iteratorId=None, result=None, hasMore=None,):
        self.iteratorId = iteratorId
        self.result = result
        self.hasMore = hasMore

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.iteratorId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.result = TMultiGetResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.hasMore = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIteratorResult')
        if self.iteratorId is not None:
            oprot.writeFieldBegin('iteratorId', TType.I64, 1)
            oprot.writeI64(self.iteratorId)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 2)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        if self.hasMore is not None:
            oprot.writeFieldBegin('hasMore', TType.BOOL, 3)
            oprot.writeBool(self.hasMore)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStatementResult(object):
    """
    A StatementResult provides information about the execution and outcome of an
    asynchronously executed table statement. If obtained via
    executionFutureGetStatus(), it can represent information about either a
    completed or in progress operation. If obtained via executionFutureGet(),
    it represents the final status of a finished operation.


    Attributes:
     - planId: The administrative plan id for this operation if the operation
    was a create or remove table, a create or remove index,
    or an alter index.

    The plan id will be 0 if this statement was not an administrative
    operation, or did not require execution.
     - info: detailed information about the status of the command execution in human
    readable form.

     - infoAsJson: detailed information about the status of the statement execution, in
    JSON text.

     - isSuccessful: true if this statement has finished and was successful.

     - errorMessage: If the operation failed, and isSuccessful is false, errorMsg will return
    a description of the problem.

     - isCancelled: true if the operation was cancelled. Not set by executeSync.

     - isDone: true if the operation has been terminated. Always true for executeSync.

    """


    def __init__(self, planId=None, info=None, infoAsJson=None, isSuccessful=None, errorMessage=None, isCancelled=None, isDone=None,):
        self.planId = planId
        self.info = info
        self.infoAsJson = infoAsJson
        self.isSuccessful = isSuccessful
        self.errorMessage = errorMessage
        self.isCancelled = isCancelled
        self.isDone = isDone

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I32:
                    self.planId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.info = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.infoAsJson = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.isSuccessful = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.errorMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.isCancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isDone = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStatementResult')
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.I32, 1)
            oprot.writeI32(self.planId)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 2)
            oprot.writeString(self.info.encode('utf-8') if sys.version_info[0] == 2 else self.info)
            oprot.writeFieldEnd()
        if self.infoAsJson is not None:
            oprot.writeFieldBegin('infoAsJson', TType.STRING, 3)
            oprot.writeString(self.infoAsJson.encode('utf-8') if sys.version_info[0] == 2 else self.infoAsJson)
            oprot.writeFieldEnd()
        if self.isSuccessful is not None:
            oprot.writeFieldBegin('isSuccessful', TType.BOOL, 4)
            oprot.writeBool(self.isSuccessful)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin('errorMessage', TType.STRING, 5)
            oprot.writeString(self.errorMessage.encode('utf-8') if sys.version_info[0] == 2 else self.errorMessage)
            oprot.writeFieldEnd()
        if self.isCancelled is not None:
            oprot.writeFieldBegin('isCancelled', TType.BOOL, 6)
            oprot.writeBool(self.isCancelled)
            oprot.writeFieldEnd()
        if self.isDone is not None:
            oprot.writeFieldBegin('isDone', TType.BOOL, 7)
            oprot.writeBool(self.isDone)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResult(object):
    """
    TResult is a union of possible result types returned via a StatementResultV2.
    It is expected that as new result types are created this union will be
    expanded.

    Attributes:
     - stringResult: A single text string result.
    """


    def __init__(self, stringResult=None,):
        self.stringResult = stringResult

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.stringResult = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResult')
        if self.stringResult is not None:
            oprot.writeFieldBegin('stringResult', TType.STRING, 1)
            oprot.writeString(self.stringResult.encode('utf-8') if sys.version_info[0] == 2 else self.stringResult)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TStatementResultV2(object):
    """
    A StatementResultV2 provides information about the execution and outcome
    of an asynchronously executed table statement. If obtained via
    executionFutureGetStatusV2(), it can represent information about either a
    completed or in progress operation. If obtained via executionFutureGetV2(),
    it represents the final status of a finished operation.


    Attributes:
     - executionId: The identification of the execution. This will be used with the
    following methods: executionFutureCancelV2, executionFutureGetV2,
    executionFutureGetTimeoutV2 and executionFutureUpdateStatusV2.

    It is null when is the result of executeSyncV2().
     - planId: The administrative plan id for this operation if the operation
    was a create or remove table, a create or remove index,
    or an alter index.

    The plan id will be 0 if this statement was not an administrative
    operation, or did not require execution.
     - info: detailed information about the status of the command execution in human
    readable form.

     - infoAsJson: detailed information about the status of the statement execution, in
    JSON text.

     - isSuccessful: true if this statement has finished and was successful.

     - errorMessage: If the operation failed, and isSuccessful is false, errorMsg will return
    a description of the problem.

     - isCancelled: true if the operation was cancelled. Not set by executeSync.

     - isDone: true if the operation has been terminated. Always true for executeSync.

     - statement: the statement of this execution

     - result: a string result if the statement has a text result value and was
    successful.

    """


    def __init__(self, executionId=None, planId=None, info=None, infoAsJson=None, isSuccessful=None, errorMessage=None, isCancelled=None, isDone=None, statement=None, result=None,):
        self.executionId = executionId
        self.planId = planId
        self.info = info
        self.infoAsJson = infoAsJson
        self.isSuccessful = isSuccessful
        self.errorMessage = errorMessage
        self.isCancelled = isCancelled
        self.isDone = isDone
        self.statement = statement
        self.result = result

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.executionId = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.planId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.info = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.infoAsJson = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.isSuccessful = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.errorMessage = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.isCancelled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.BOOL:
                    self.isDone = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.STRING:
                    self.statement = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.result = TResult()
                    self.result.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TStatementResultV2')
        if self.executionId is not None:
            oprot.writeFieldBegin('executionId', TType.STRING, 1)
            oprot.writeBinary(self.executionId)
            oprot.writeFieldEnd()
        if self.planId is not None:
            oprot.writeFieldBegin('planId', TType.I32, 2)
            oprot.writeI32(self.planId)
            oprot.writeFieldEnd()
        if self.info is not None:
            oprot.writeFieldBegin('info', TType.STRING, 3)
            oprot.writeString(self.info.encode('utf-8') if sys.version_info[0] == 2 else self.info)
            oprot.writeFieldEnd()
        if self.infoAsJson is not None:
            oprot.writeFieldBegin('infoAsJson', TType.STRING, 4)
            oprot.writeString(self.infoAsJson.encode('utf-8') if sys.version_info[0] == 2 else self.infoAsJson)
            oprot.writeFieldEnd()
        if self.isSuccessful is not None:
            oprot.writeFieldBegin('isSuccessful', TType.BOOL, 5)
            oprot.writeBool(self.isSuccessful)
            oprot.writeFieldEnd()
        if self.errorMessage is not None:
            oprot.writeFieldBegin('errorMessage', TType.STRING, 6)
            oprot.writeString(self.errorMessage.encode('utf-8') if sys.version_info[0] == 2 else self.errorMessage)
            oprot.writeFieldEnd()
        if self.isCancelled is not None:
            oprot.writeFieldBegin('isCancelled', TType.BOOL, 7)
            oprot.writeBool(self.isCancelled)
            oprot.writeFieldEnd()
        if self.isDone is not None:
            oprot.writeFieldBegin('isDone', TType.BOOL, 8)
            oprot.writeBool(self.isDone)
            oprot.writeFieldEnd()
        if self.statement is not None:
            oprot.writeFieldBegin('statement', TType.STRING, 9)
            oprot.writeString(self.statement.encode('utf-8') if sys.version_info[0] == 2 else self.statement)
            oprot.writeFieldEnd()
        if self.result is not None:
            oprot.writeFieldBegin('result', TType.STRUCT, 10)
            self.result.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TOperation(object):
    """
    Defines an update operation to be passed to executeUpdates.


    Attributes:
     - tableName: The table name on which this operation is executed on.

     - type: Determines which update operation to be executed.

     - row: For put operations: represents the row to be stored.
    For delete operations: represents the key of the row to be deleted.

     - returnChoice: Specifies whether to return the row value, version, both or neither.

     - abortIfUnsuccessful: true if this operation should cause the execute transaction to abort
    when the operation fails, where failure is the condition when the
    delete or put method returns null.

     - matchVersion: The version to be matched for: putIfVersion and deleteIfVersion.

    """


    def __init__(self, tableName=None, type=None, row=None, returnChoice=None, abortIfUnsuccessful=None, matchVersion=None,):
        self.tableName = tableName
        self.type = type
        self.row = row
        self.returnChoice = returnChoice
        self.abortIfUnsuccessful = abortIfUnsuccessful
        self.matchVersion = matchVersion

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.tableName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.row = TRow()
                    self.row.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.returnChoice = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.abortIfUnsuccessful = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.matchVersion = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TOperation')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 1)
            oprot.writeString(self.tableName.encode('utf-8') if sys.version_info[0] == 2 else self.tableName)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.I32, 2)
            oprot.writeI32(self.type)
            oprot.writeFieldEnd()
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRUCT, 3)
            self.row.write(oprot)
            oprot.writeFieldEnd()
        if self.returnChoice is not None:
            oprot.writeFieldBegin('returnChoice', TType.I32, 4)
            oprot.writeI32(self.returnChoice)
            oprot.writeFieldEnd()
        if self.abortIfUnsuccessful is not None:
            oprot.writeFieldBegin('abortIfUnsuccessful', TType.BOOL, 5)
            oprot.writeBool(self.abortIfUnsuccessful)
            oprot.writeFieldEnd()
        if self.matchVersion is not None:
            oprot.writeFieldBegin('matchVersion', TType.STRING, 6)
            oprot.writeBinary(self.matchVersion)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDurabilityException(TException):
    """
    Attributes:
     - availableReplicas
     - commitPolicy
     - requiredNodeCount
     - message
    """


    def __init__(self, availableReplicas=None, commitPolicy=None, requiredNodeCount=None, message=None,):
        self.availableReplicas = availableReplicas
        self.commitPolicy = commitPolicy
        self.requiredNodeCount = requiredNodeCount
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.availableReplicas = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.availableReplicas.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.commitPolicy = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.requiredNodeCount = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDurabilityException')
        if self.availableReplicas is not None:
            oprot.writeFieldBegin('availableReplicas', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.availableReplicas))
            for iter36 in self.availableReplicas:
                oprot.writeString(iter36.encode('utf-8') if sys.version_info[0] == 2 else iter36)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.commitPolicy is not None:
            oprot.writeFieldBegin('commitPolicy', TType.I32, 2)
            oprot.writeI32(self.commitPolicy)
            oprot.writeFieldEnd()
        if self.requiredNodeCount is not None:
            oprot.writeFieldBegin('requiredNodeCount', TType.I32, 3)
            oprot.writeI32(self.requiredNodeCount)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 4)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRequestTimeoutException(TException):
    """
    Attributes:
     - message
     - timeoutMs
    """


    def __init__(self, message=None, timeoutMs=None,):
        self.message = message
        self.timeoutMs = timeoutMs

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.timeoutMs = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRequestTimeoutException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        if self.timeoutMs is not None:
            oprot.writeFieldBegin('timeoutMs', TType.I64, 2)
            oprot.writeI64(self.timeoutMs)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TFaultException(TException):
    """
    Attributes:
     - faultClassName
     - remoteStackTrace
     - wasLoggedRemotely
     - message
    """


    def __init__(self, faultClassName=None, remoteStackTrace=None, wasLoggedRemotely=None, message=None,):
        self.faultClassName = faultClassName
        self.remoteStackTrace = remoteStackTrace
        self.wasLoggedRemotely = wasLoggedRemotely
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.faultClassName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.remoteStackTrace = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.wasLoggedRemotely = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TFaultException')
        if self.faultClassName is not None:
            oprot.writeFieldBegin('faultClassName', TType.STRING, 1)
            oprot.writeString(self.faultClassName.encode('utf-8') if sys.version_info[0] == 2 else self.faultClassName)
            oprot.writeFieldEnd()
        if self.remoteStackTrace is not None:
            oprot.writeFieldBegin('remoteStackTrace', TType.STRING, 2)
            oprot.writeString(self.remoteStackTrace.encode('utf-8') if sys.version_info[0] == 2 else self.remoteStackTrace)
            oprot.writeFieldEnd()
        if self.wasLoggedRemotely is not None:
            oprot.writeFieldBegin('wasLoggedRemotely', TType.BOOL, 3)
            oprot.writeBool(self.wasLoggedRemotely)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 4)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TConsistencyException(TException):
    """
    Attributes:
     - consistencyPolicy
     - message
    """


    def __init__(self, consistencyPolicy=None, message=None,):
        self.consistencyPolicy = consistencyPolicy
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.consistencyPolicy = TConsistency()
                    self.consistencyPolicy.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TConsistencyException')
        if self.consistencyPolicy is not None:
            oprot.writeFieldBegin('consistencyPolicy', TType.STRUCT, 1)
            self.consistencyPolicy.write(oprot)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 2)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIllegalArgumentException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIllegalArgumentException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIteratorTimeoutException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIteratorTimeoutException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnverifiedConnectionException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnverifiedConnectionException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TProxyException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TProxyException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCancellationException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCancellationException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TExecutionException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TExecutionException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TInterruptedException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TInterruptedException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTimeoutException(TException):
    """
    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeoutException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableOpExecutionException(TException):
    """
    Used to indicate a failure in executeUpdates.


    Attributes:
     - operation: The operation that caused the execution to be aborted. *
     - failedOperationIndex: The list index of the operation that caused the execution to be aborted. *
     - operationResult: The result of the operation that caused the execution to be aborted. *
     - message: The exception message
    """


    def __init__(self, operation=None, failedOperationIndex=None, operationResult=None, message=None,):
        self.operation = operation
        self.failedOperationIndex = failedOperationIndex
        self.operationResult = operationResult
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.operation = TOperation()
                    self.operation.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.failedOperationIndex = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.operationResult = TWriteResult()
                    self.operationResult.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableOpExecutionException')
        if self.operation is not None:
            oprot.writeFieldBegin('operation', TType.STRUCT, 1)
            self.operation.write(oprot)
            oprot.writeFieldEnd()
        if self.failedOperationIndex is not None:
            oprot.writeFieldBegin('failedOperationIndex', TType.I32, 2)
            oprot.writeI32(self.failedOperationIndex)
            oprot.writeFieldEnd()
        if self.operationResult is not None:
            oprot.writeFieldBegin('operationResult', TType.STRUCT, 3)
            self.operationResult.write(oprot)
            oprot.writeFieldEnd()
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 4)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRequestLimitException(TException):
    """
    Thrown when a request cannot be processed because it would exceed the
    maximum number of active requests for a node as configured by
    -request-limit.


    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRequestLimitException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthenticationFailureException(TException):
    """
    This exception is thrown if an application passes invalid credentials to
    an authentication operation.


    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthenticationFailureException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthenticationRequiredException(TException):
    """
    This exception is thrown when a secured operation is attempted and the
    client is not currently authenticated. It can occur if login credentials
    were specified, but the login session has expired, requiring that the client
    reauthenticate itself.


    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthenticationRequiredException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TUnauthorizedException(TException):
    """
    This exception is thrown from methods where an authenticated user is
    attempting to perform an operation for which they are not authorized.
    An application that receives this exception typically should not retry the
    operation.


    Attributes:
     - message
    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TUnauthorizedException')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TVerifyProperties)
TVerifyProperties.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'kvStoreName', 'UTF8', None, ),  # 1
    (2, TType.LIST, 'kvStoreHelperHosts', (TType.STRING, 'UTF8', False), None, ),  # 2
    (3, TType.STRING, 'username', 'UTF8', None, ),  # 3
    (4, TType.LIST, 'readZones', (TType.STRING, 'UTF8', False), None, ),  # 4
    (5, TType.I32, 'driverProtocolVersion', None, None, ),  # 5
)
all_structs.append(TVerifyResult)
TVerifyResult.thrift_spec = (
    None,  # 0
    (1, TType.BOOL, 'isConnected', None, None, ),  # 1
    (2, TType.I32, 'errorType', None, None, ),  # 2
    (3, TType.STRING, 'message', 'UTF8', None, ),  # 3
    (4, TType.I32, 'proxyProtocolVersion', None, 4, ),  # 4
)
all_structs.append(TDurability)
TDurability.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'masterSync', None, None, ),  # 1
    (2, TType.I32, 'replicaAck', None, None, ),  # 2
    (3, TType.I32, 'replicaSync', None, None, ),  # 3
)
all_structs.append(TWriteOptions)
TWriteOptions.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'durability', [TDurability, None], None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
    (3, TType.I32, 'returnChoice', None, None, ),  # 3
    (4, TType.BOOL, 'updateTTL', None, False, ),  # 4
)
all_structs.append(TTimeConsistency)
TTimeConsistency.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'permissibleLag', None, None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
)
all_structs.append(TVersionConsistency)
TVersionConsistency.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'version', 'BINARY', None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
)
all_structs.append(TConsistency)
TConsistency.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'simple', None, None, ),  # 1
    (2, TType.STRUCT, 'time', [TTimeConsistency, None], None, ),  # 2
    (3, TType.STRUCT, 'version', [TVersionConsistency, None], None, ),  # 3
)
all_structs.append(TReadOptions)
TReadOptions.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'consistency', [TConsistency, None], None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
)
all_structs.append(TTimeToLive)
TTimeToLive.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'value', None, None, ),  # 1
    (2, TType.I32, 'timeUnit', None, None, ),  # 2
)
all_structs.append(TRow)
TRow.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jsonRow', 'UTF8', None, ),  # 1
    (2, TType.STRUCT, 'ttl', [TTimeToLive, None], None, ),  # 2
)
all_structs.append(TWriteResult)
TWriteResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'currentRowVersion', 'BINARY', None, ),  # 1
    (2, TType.STRUCT, 'previousRow', [TRow, None], None, ),  # 2
    (3, TType.STRING, 'previousRowVersion', 'BINARY', None, ),  # 3
    (4, TType.BOOL, 'wasDeleted', None, None, ),  # 4
    (5, TType.I64, 'expiration', None, 0, ),  # 5
)
all_structs.append(TGetResult)
TGetResult.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'currentRow', [TRow, None], None, ),  # 1
    (2, TType.STRING, 'currentRowVersion', 'BINARY', None, ),  # 2
    (3, TType.I64, 'expiration', None, 0, ),  # 3
)
all_structs.append(TFieldRange)
TFieldRange.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'fieldName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'startValue', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'startIsInclusive', None, None, ),  # 3
    (4, TType.STRING, 'endValue', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'endIsInclusive', None, None, ),  # 5
)
all_structs.append(TRowAndMetadata)
TRowAndMetadata.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'jsonRow', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'rowVersion', 'BINARY', None, ),  # 2
    (3, TType.I32, 'tableId', None, None, ),  # 3
    (4, TType.I64, 'expiration', None, 0, ),  # 4
)
all_structs.append(TMultiGetResult)
TMultiGetResult.thrift_spec = (
    None,  # 0
    (1, TType.MAP, 'idToTableNames', (TType.I32, None, TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.LIST, 'rowsWithMetadata', (TType.STRUCT, [TRowAndMetadata, None], False), None, ),  # 2
)
all_structs.append(TIteratorResult)
TIteratorResult.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'iteratorId', None, None, ),  # 1
    (2, TType.STRUCT, 'result', [TMultiGetResult, None], None, ),  # 2
    (3, TType.BOOL, 'hasMore', None, None, ),  # 3
)
all_structs.append(TStatementResult)
TStatementResult.thrift_spec = (
    None,  # 0
    (1, TType.I32, 'planId', None, None, ),  # 1
    (2, TType.STRING, 'info', 'UTF8', None, ),  # 2
    (3, TType.STRING, 'infoAsJson', 'UTF8', None, ),  # 3
    (4, TType.BOOL, 'isSuccessful', None, None, ),  # 4
    (5, TType.STRING, 'errorMessage', 'UTF8', None, ),  # 5
    (6, TType.BOOL, 'isCancelled', None, None, ),  # 6
    (7, TType.BOOL, 'isDone', None, None, ),  # 7
)
all_structs.append(TResult)
TResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'stringResult', 'UTF8', None, ),  # 1
)
all_structs.append(TStatementResultV2)
TStatementResultV2.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'executionId', 'BINARY', None, ),  # 1
    (2, TType.I32, 'planId', None, None, ),  # 2
    (3, TType.STRING, 'info', 'UTF8', None, ),  # 3
    (4, TType.STRING, 'infoAsJson', 'UTF8', None, ),  # 4
    (5, TType.BOOL, 'isSuccessful', None, None, ),  # 5
    (6, TType.STRING, 'errorMessage', 'UTF8', None, ),  # 6
    (7, TType.BOOL, 'isCancelled', None, None, ),  # 7
    (8, TType.BOOL, 'isDone', None, None, ),  # 8
    (9, TType.STRING, 'statement', 'UTF8', None, ),  # 9
    (10, TType.STRUCT, 'result', [TResult, None], None, ),  # 10
)
all_structs.append(TOperation)
TOperation.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'tableName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'type', None, None, ),  # 2
    (3, TType.STRUCT, 'row', [TRow, None], None, ),  # 3
    (4, TType.I32, 'returnChoice', None, None, ),  # 4
    (5, TType.BOOL, 'abortIfUnsuccessful', None, None, ),  # 5
    (6, TType.STRING, 'matchVersion', 'BINARY', None, ),  # 6
)
all_structs.append(TDurabilityException)
TDurabilityException.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'availableReplicas', (TType.STRING, 'UTF8', False), None, ),  # 1
    (2, TType.I32, 'commitPolicy', None, None, ),  # 2
    (3, TType.I32, 'requiredNodeCount', None, None, ),  # 3
    (4, TType.STRING, 'message', 'UTF8', None, ),  # 4
)
all_structs.append(TRequestTimeoutException)
TRequestTimeoutException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
    (2, TType.I64, 'timeoutMs', None, None, ),  # 2
)
all_structs.append(TFaultException)
TFaultException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'faultClassName', 'UTF8', None, ),  # 1
    (2, TType.STRING, 'remoteStackTrace', 'UTF8', None, ),  # 2
    (3, TType.BOOL, 'wasLoggedRemotely', None, None, ),  # 3
    (4, TType.STRING, 'message', 'UTF8', None, ),  # 4
)
all_structs.append(TConsistencyException)
TConsistencyException.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'consistencyPolicy', [TConsistency, None], None, ),  # 1
    (2, TType.STRING, 'message', 'UTF8', None, ),  # 2
)
all_structs.append(TIllegalArgumentException)
TIllegalArgumentException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TIteratorTimeoutException)
TIteratorTimeoutException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TUnverifiedConnectionException)
TUnverifiedConnectionException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TProxyException)
TProxyException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TCancellationException)
TCancellationException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TExecutionException)
TExecutionException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TInterruptedException)
TInterruptedException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TTimeoutException)
TTimeoutException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TTableOpExecutionException)
TTableOpExecutionException.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'operation', [TOperation, None], None, ),  # 1
    (2, TType.I32, 'failedOperationIndex', None, None, ),  # 2
    (3, TType.STRUCT, 'operationResult', [TWriteResult, None], None, ),  # 3
    (4, TType.STRING, 'message', 'UTF8', None, ),  # 4
)
all_structs.append(TRequestLimitException)
TRequestLimitException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TAuthenticationFailureException)
TAuthenticationFailureException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TAuthenticationRequiredException)
TAuthenticationRequiredException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TUnauthorizedException)
TUnauthorizedException.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
